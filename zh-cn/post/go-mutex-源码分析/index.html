<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Go Mutex 源码分析 - Tender Night</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="intxff"><meta name=description content="源码版本是 go 1.21，主要分析 sync.Mutex 中的内容，搞清楚加解锁过程和其中的调度过程。分析时请记住 Mutex 是被多个 goroutine 共享的量，每个协程都在运行代码中不同的位"><meta name=keywords content="Hugo,theme,even"><meta name=generator content="Hugo 0.114.0 with theme even"><link rel=canonical href=/zh-cn/post/go-mutex-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Go Mutex 源码分析"><meta property="og:description" content="源码版本是 go 1.21，主要分析 sync.Mutex 中的内容，搞清楚加解锁过程和其中的调度过程。分析时请记住 Mutex 是被多个 goroutine 共享的量，每个协程都在运行代码中不同的位"><meta property="og:type" content="article"><meta property="og:url" content="/zh-cn/post/go-mutex-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-11-05T20:37:57+08:00"><meta property="article:modified_time" content="2023-11-05T20:37:57+08:00"><meta itemprop=name content="Go Mutex 源码分析"><meta itemprop=description content="源码版本是 go 1.21，主要分析 sync.Mutex 中的内容，搞清楚加解锁过程和其中的调度过程。分析时请记住 Mutex 是被多个 goroutine 共享的量，每个协程都在运行代码中不同的位"><meta itemprop=datePublished content="2023-11-05T20:37:57+08:00"><meta itemprop=dateModified content="2023-11-05T20:37:57+08:00"><meta itemprop=wordCount content="4649"><meta itemprop=keywords content="mutex,go,锁,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go Mutex 源码分析"><meta name=twitter:description content="源码版本是 go 1.21，主要分析 sync.Mutex 中的内容，搞清楚加解锁过程和其中的调度过程。分析时请记住 Mutex 是被多个 goroutine 共享的量，每个协程都在运行代码中不同的位"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/zh-cn/ class=logo>Tender Night</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a></ul><div class=language-selector><ul class=languages-list><li class="language-item active"><a href=/zh-cn/post/go-mutex-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>中文</a></li><li class=language-item><a href=/en-us/>EN</a></li></ul></div></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/zh-cn/ class=logo>Tender Night</a></div><div class=language-selector><ul class=languages-list><li class="language-item active"><a href=/zh-cn/post/go-mutex-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>中文</a></li><li class=language-item><a href=/en-us/>EN</a></li></ul></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/zh-cn/>首页</a></li><li class=menu-item><a class=menu-item-link href=/zh-cn/post/>归档</a></li><li class=menu-item><a class=menu-item-link href=/zh-cn/tags/>标签</a></li><li class=menu-item><a class=menu-item-link href=/zh-cn/categories/>分类</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Go Mutex 源码分析</h1><div class=post-meta><span class=post-time>2023-11-05</span><div class=post-category><a href=/zh-cn/categories/go-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>Go 源码分析</a>
<a href=/zh-cn/categories/%E5%A4%8D%E8%AF%BB%E6%9C%BA/>复读机</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#概览>概览</a></li><li><a href=#相关数据结构>相关数据结构</a></li><li><a href=#加解锁过程>加解锁过程</a><ul><li><a href=#完整代码注解>完整代码注解</a></li><li><a href=#协程状态变化>协程状态变化</a><ul><li><a href=#awoke><code>awoke</code></a></li><li><a href=#starving><code>starving</code></a></li></ul></li><li><a href=#锁的状态变化>锁的状态变化</a><ul><li><a href=#mutexlocked><code>mutexLocked</code></a></li><li><a href=#mutexwoken><code>mutexWoken</code></a></li><li><a href=#mutexstarving><code>mutexStarving</code></a></li></ul></li></ul></li><li><a href=#过程模拟>过程模拟</a></li><li><a href=#总结>总结</a><ul><li><a href=#正常模式>正常模式</a></li><li><a href=#饥饿模式>饥饿模式</a></li><li><a href=#切换时机>切换时机</a></li></ul></li></ul></nav></div></div><div class=post-content><p>源码版本是 go 1.21，主要分析 <a href=https://github.com/golang/go/blob/release-branch.go1.21/src/sync/mutex.go><code>sync.Mutex</code></a> 中的内容，搞清楚加解锁过程和其中的调度过程。分析时请记住 <code>Mutex</code> 是被多个 <code>goroutine</code> 共享的量，每个协程都在运行代码中不同的位置。为了彻底搞清楚，最后会给出一个多协程并发运行的模拟。</p><blockquote><p>为了阅读流畅，这里把用到的相关代码全都复制了出来</p><ul><li><code>// [file]</code> 标注文件路径</li><li><code>// (func)</code> 标注所在函数</li></ul></blockquote><h1 id=概览>概览</h1><p>参与整个过程的是竞争锁的协程和锁本身，协程的来源有两个，一个是正在运行的或 <code>P</code> 中任务队列调度的协程，还有就是之前获取锁失败，被调度到 <code>semtable</code> 全局信号量中的协程。显然，前者的协程间切换代价小，后者需要 <code>sema</code> 调度切换代价大，所以优先让前者获得锁，为了达到这个目的，锁中的 <code>mutexWoken</code> 和协程中的局部变量 <code>awoke</code> 配合解决。如果一直按照优先来给锁，后者极端情况下会一直获得不到锁，所以又引入 <code>mutexStarving</code> 和协程局部变量 <code>staving</code> 解决。</p><h1 id=相关数据结构>相关数据结构</h1><ul><li><code>Mutex</code></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// [sync/Mutex.go]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Mutex</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>state</span> <span class=kt>int32</span>
</span></span><span class=line><span class=cl>    <span class=nx>sema</span>  <span class=kt>uint32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>mutexLocked</span> <span class=p>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=kc>iota</span> <span class=c1>// mutex is locked
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>mutexWoken</span>
</span></span><span class=line><span class=cl>    <span class=nx>mutexStarving</span>
</span></span><span class=line><span class=cl>    <span class=nx>mutexWaiterShift</span> <span class=p>=</span> <span class=kc>iota</span>
</span></span><span class=line><span class=cl>    <span class=nx>starvationThresholdNs</span> <span class=p>=</span> <span class=mf>1e6</span> <span class=c1>// = 1 ms
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><code>Mutex.state</code> 是个复合量，结合随后定义的常量，可以知道前 29 位是等待的协程数，30 位表示饥饿状态标志，31 位是锁是否处于唤醒状态标志，最后一位是锁是否处于锁定状态标志，这些状态在下面分析代码时解释意义。<code>Mutex.sema</code> 实际是使用了 <a href=https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/sema.go><code>runtime/sema.go</code></a> 的未导出内容，使用方法是通过 <a href=https://pkg.go.dev/cmd/compile@go1.21.0><code>linkname</code></a>(但是仔细观察会发现，跟文档说明的方法并不一致，猜测是构建时生成或引入 .s 文件逃避编译器 <code>complete</code> 要求，有懂的可以告诉我！)，信号量在这里起调度作用。</p><ul><li><code>Sema</code> 相关</li></ul><p>中间有类似 <code>runtime_SemacquireMutex</code> 的信号量函数，所以这里也要看下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// [runtime/sema.go]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>semaRoot</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>lock</span>  <span class=nx>mutex</span> <span class=c1>// 这个 mutex 跟 sync.Mutex 不是一个东西
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nx>treap</span> <span class=o>*</span><span class=nx>sudog</span>        <span class=c1>// root of balanced tree of unique waiters.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>nwait</span> <span class=nx>atomic</span><span class=p>.</span><span class=nx>Uint32</span> <span class=c1>// Number of waiters. Read w/o the lock.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>semtable</span> <span class=nx>semTable</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Prime to not correlate with any user patterns.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>const</span> <span class=nx>semTabSize</span> <span class=p>=</span> <span class=mi>251</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>semTable</span> <span class=p>[</span><span class=nx>semTabSize</span><span class=p>]</span><span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>root</span> <span class=nx>semaRoot</span>
</span></span><span class=line><span class=cl>    <span class=nx>pad</span>  <span class=p>[</span><span class=nx>cpu</span><span class=p>.</span><span class=nx>CacheLinePadSize</span> <span class=o>-</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nx>semaRoot</span><span class=p>{})]</span><span class=kt>byte</span> <span class=c1>// 防止缓存 false sharing
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// [runtime/runtime2.go]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>mutex</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Empty struct if lock ranking is disabled, otherwise includes the lock rank
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>lockRankStruct</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Futex-based impl treats it as uint32 key,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// while sema-based impl as M* waitm.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Used to be a union, but unions break precise GC.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>key</span> <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// sudog represents a g in a wait list, such as for sending/receiving
</span></span></span><span class=line><span class=cl><span class=c1>// on a channel.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// sudog is necessary because the g ↔ synchronization object relation
</span></span></span><span class=line><span class=cl><span class=c1>// is many-to-many. A g can be on many wait lists, so there may be
</span></span></span><span class=line><span class=cl><span class=c1>// many sudogs for one g; and many gs may be waiting on the same
</span></span></span><span class=line><span class=cl><span class=c1>// synchronization object, so there may be many sudogs for one object.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// sudogs are allocated from a special pool. Use acquireSudog and
</span></span></span><span class=line><span class=cl><span class=c1>// releaseSudog to allocate and free them.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>sudog</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// The following fields are protected by the hchan.lock of the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// channel this sudog is blocking on. shrinkstack depends on
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// this for sudogs involved in channel ops.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nx>g</span> <span class=o>*</span><span class=nx>g</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>next</span> <span class=o>*</span><span class=nx>sudog</span>
</span></span><span class=line><span class=cl>    <span class=nx>prev</span> <span class=o>*</span><span class=nx>sudog</span>
</span></span><span class=line><span class=cl>    <span class=nx>elem</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// data element (may point to stack)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// The following fields are never accessed concurrently.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// For channels, waitlink is only accessed by g.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// For semaphores, all fields (including the ones above)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// are only accessed when holding a semaRoot lock.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nx>acquiretime</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl>    <span class=nx>releasetime</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl>    <span class=nx>ticket</span>      <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// isSelect indicates g is participating in a select, so
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// g.selectDone must be CAS&#39;d to win the wake-up race.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>isSelect</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// success indicates whether communication over channel c
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// succeeded. It is true if the goroutine was awoken because a
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// value was delivered over channel c, and false if awoken
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// because c was closed.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>success</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>parent</span>   <span class=o>*</span><span class=nx>sudog</span> <span class=c1>// semaRoot binary tree
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>waitlink</span> <span class=o>*</span><span class=nx>sudog</span> <span class=c1>// g.waiting list or semaRoot
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>waittail</span> <span class=o>*</span><span class=nx>sudog</span> <span class=c1>// semaRoot
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>c</span>        <span class=o>*</span><span class=nx>hchan</span> <span class=c1>// channel
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>semtable</code> 在程序中是个全局变量，有 251 个 <code>semaRoot</code>，每个根内有以 <code>sudog</code> 为节点的平衡二叉树，<code>sudog</code> 就是 <code>sudo</code> <code>g</code> (伪 <code>g</code>)，所有因为各种原因阻塞的 <code>g</code> 都被放到这个结构体中，具体解释我觉得官方的注释很清楚，就不说了。根内的 <code>mutex</code> 的 <code>key</code> 是个地址。</p><h1 id=加解锁过程>加解锁过程</h1><h2 id=完整代码注解>完整代码注解</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// [sync/mutex.go]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Mutex</span><span class=p>)</span> <span class=nf>Lock</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Fast path: grab unlocked mutex.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>mutexLocked</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>race</span><span class=p>.</span><span class=nx>Enabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>race</span><span class=p>.</span><span class=nf>Acquire</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>m</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Slow path (outlined so that the fast path can be inlined)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>m</span><span class=p>.</span><span class=nf>lockSlow</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Mutex</span><span class=p>)</span> <span class=nf>lockSlow</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 记住在这里声明定义的变量都是每个协程自己私有的，只有 Mutex 是共享
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>waitStartTime</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 以下变量是表示当前协程的状态，不是锁的状态
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>starving</span> <span class=o>:=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=nx>awoke</span> <span class=o>:=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=nx>iter</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 区分 old 和 m.state
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// old 是当前这条指令执行时锁的状态
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// m.state 是即时的锁状态，随时都会被其他协程改变
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>old</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>state</span> 
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Don&#39;t spin in starvation mode, ownership is handed off to waiters
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// so we won&#39;t be able to acquire the mutex anyway.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 当前锁已经被锁定且不处于饥饿状态，同时可以进入自旋状态
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 如果锁饥饿，说明有别的协程急着用锁，当前协程再自旋占用时间不合理
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>old</span><span class=o>&amp;</span><span class=p>(</span><span class=nx>mutexLocked</span><span class=p>|</span><span class=nx>mutexStarving</span><span class=p>)</span> <span class=o>==</span> <span class=nx>mutexLocked</span> <span class=o>&amp;&amp;</span> <span class=nf>runtime_canSpin</span><span class=p>(</span><span class=nx>iter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Active spinning makes sense.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// Try to set mutexWoken flag to inform Unlock
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// to not wake other blocked goroutines.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 当前协程未处于唤醒状态
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 当前锁的状态是未唤醒
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 等待锁的协程数不为0
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 并且即时锁的状态没有发生改变
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=p>!</span><span class=nx>awoke</span> <span class=o>&amp;&amp;</span> <span class=nx>old</span><span class=o>&amp;</span><span class=nx>mutexWoken</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>old</span><span class=o>&gt;&gt;</span><span class=nx>mutexWaiterShift</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=nx>old</span><span class=p>,</span> <span class=nx>old</span><span class=p>|</span><span class=nx>mutexWoken</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>awoke</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=nf>runtime_doSpin</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=nx>iter</span><span class=o>++</span>
</span></span><span class=line><span class=cl>            <span class=nx>old</span> <span class=p>=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>state</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// new 是本次调度结束后，根据 old 和协程状态确定锁之后的状态
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>new</span> <span class=o>:=</span> <span class=nx>old</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Don&#39;t try to acquire starving mutex, new arriving goroutines must queue.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 锁不饥饿，要么当前协程运行完获得锁要么获得不到，锁的新状态还应该是锁定
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>old</span><span class=o>&amp;</span><span class=nx>mutexStarving</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>new</span> <span class=o>|=</span> <span class=nx>mutexLocked</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 可能饥饿也可能锁定，无论饥饿还是锁定，当前协程都无法获得锁，需要加入到等待队列中
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>old</span><span class=o>&amp;</span><span class=p>(</span><span class=nx>mutexLocked</span><span class=p>|</span><span class=nx>mutexStarving</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>new</span> <span class=o>+=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=nx>mutexWaiterShift</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// The current goroutine switches mutex to starvation mode.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// But if the mutex is currently unlocked, don&#39;t do the switch.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// Unlock expects that starving mutex has waiters, which will not
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// be true in this case.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 当前协程饥饿，同时锁是锁定的，需要更新锁到饥饿状态，告知别的协程让给当前协程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>starving</span> <span class=o>&amp;&amp;</span> <span class=nx>old</span><span class=o>&amp;</span><span class=nx>mutexLocked</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>new</span> <span class=o>|=</span> <span class=nx>mutexStarving</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 当前协程被唤醒，之前就可能有 mutexWoken 被设置了，需要清除标记
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>awoke</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// The goroutine has been woken from sleep,
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// so we need to reset the flag in either case.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=nx>new</span><span class=o>&amp;</span><span class=nx>mutexWoken</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;sync: inconsistent mutex state&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=nx>new</span> <span class=o>&amp;^=</span> <span class=nx>mutexWoken</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 如果 old 跟即时状态一样，则改变 m.state 为 new，否则更新 old 到即时状态开始新的循环
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=nx>old</span><span class=p>,</span> <span class=nx>new</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 锁既没被锁定，也不处于饥饿，那么直接获得锁走人
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=nx>old</span><span class=o>&amp;</span><span class=p>(</span><span class=nx>mutexLocked</span><span class=p>|</span><span class=nx>mutexStarving</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span> <span class=c1>// locked the mutex with CAS
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=c1>// If we were already waiting before, queue at the front of the queue.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>queueLifo</span> <span class=o>:=</span> <span class=nx>waitStartTime</span> <span class=o>!=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>waitStartTime</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>waitStartTime</span> <span class=p>=</span> <span class=nf>runtime_nanotime</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 将当前协程放到队列中等待调度
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>runtime_SemacquireMutex</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>sema</span><span class=p>,</span> <span class=nx>queueLifo</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 调度结束，更新协程和锁的状态
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>starving</span> <span class=p>=</span> <span class=nx>starving</span> <span class=o>||</span> <span class=nf>runtime_nanotime</span><span class=p>()</span><span class=o>-</span><span class=nx>waitStartTime</span> <span class=p>&gt;</span> <span class=nx>starvationThresholdNs</span>
</span></span><span class=line><span class=cl>            <span class=nx>old</span> <span class=p>=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>state</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 锁在饥饿状态
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 这里其实隐含了些信息，锁饥饿，当前协程还能被调度到前台执行，说明当前协程是在等待队列
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 的首部，上次调度前，当前协程就已经饥饿，只不过由于 waitStartTime = 0 没有放到队首
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=nx>old</span><span class=o>&amp;</span><span class=nx>mutexStarving</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// If this goroutine was woken and mutex is in starvation mode,
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// ownership was handed off to us but mutex is in somewhat
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// inconsistent state: mutexLocked is not set and we are still
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// accounted as waiter. Fix that.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// 饥饿态的锁不可能等待者数目为 0
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// 必须 old[30:32] = 00
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=nx>old</span><span class=o>&amp;</span><span class=p>(</span><span class=nx>mutexLocked</span><span class=p>|</span><span class=nx>mutexWoken</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>old</span><span class=o>&gt;&gt;</span><span class=nx>mutexWaiterShift</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;sync: inconsistent mutex state&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=c1>// delta 补码 = 0x(1*[29])001 waiters 位全为 1，mutexLocked 位为 1，其他为 0
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nx>delta</span> <span class=o>:=</span> <span class=nb>int32</span><span class=p>(</span><span class=nx>mutexLocked</span> <span class=o>-</span> <span class=mi>1</span><span class=o>&lt;&lt;</span><span class=nx>mutexWaiterShift</span><span class=p>)</span> <span class=c1>// -7
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// 锁在饥饿态，饥饿的不是当前协程或者等待的协程数为 1，则说明当前协程结束后，锁应该不在饥饿态
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=p>!</span><span class=nx>starving</span> <span class=o>||</span> <span class=nx>old</span><span class=o>&gt;&gt;</span><span class=nx>mutexWaiterShift</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// Exit starvation mode.
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=c1>// Critical to do it here and consider wait time.
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=c1>// Starvation mode is so inefficient, that two goroutines
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=c1>// can go lock-step infinitely once they switch mutex
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=c1>// to starvation mode.
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=c1>// delta 补码 = 0x(1*[29])001 + 0x(1*[29])100 = 0x(1*[28])0101
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=nx>delta</span> <span class=o>-=</span> <span class=nx>mutexStarving</span> <span class=c1>// -11
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=nx>atomic</span><span class=p>.</span><span class=nf>AddInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=nx>delta</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=nx>awoke</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>            <span class=nx>iter</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>old</span> <span class=p>=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>state</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>race</span><span class=p>.</span><span class=nx>Enabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>race</span><span class=p>.</span><span class=nf>Acquire</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>m</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Unlock unlocks m.
</span></span></span><span class=line><span class=cl><span class=c1>// It is a run-time error if m is not locked on entry to Unlock.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// A locked Mutex is not associated with a particular goroutine.
</span></span></span><span class=line><span class=cl><span class=c1>// It is allowed for one goroutine to lock a Mutex and then
</span></span></span><span class=line><span class=cl><span class=c1>// arrange for another goroutine to unlock it.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Mutex</span><span class=p>)</span> <span class=nf>Unlock</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>race</span><span class=p>.</span><span class=nx>Enabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>_</span> <span class=p>=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>state</span>
</span></span><span class=line><span class=cl>        <span class=nx>race</span><span class=p>.</span><span class=nf>Release</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>m</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Fast path: drop lock bit.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 这里 mutexLocked 状态位为 0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 但是这里有坑，Unlock 并没有限制与 Lock 一一对应，如果调用一次 Lock，然后多次
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Unlock 就会有问题，后续 slow path 可能会 panic
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>new</span> <span class=o>:=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>AddInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=o>-</span><span class=nx>mutexLocked</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 没有等待者，直接获取
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>new</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Outlined slow path to allow inlining the fast path.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>m</span><span class=p>.</span><span class=nf>unlockSlow</span><span class=p>(</span><span class=nx>new</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Mutex</span><span class=p>)</span> <span class=nf>unlockSlow</span><span class=p>(</span><span class=nx>new</span> <span class=kt>int32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>new</span><span class=o>+</span><span class=nx>mutexLocked</span><span class=p>)</span><span class=o>&amp;</span><span class=nx>mutexLocked</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fatal</span><span class=p>(</span><span class=s>&#34;sync: unlock of unlocked mutex&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 进入后 new[29:32] = {0, x, 0}
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>new</span><span class=o>&amp;</span><span class=nx>mutexStarving</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>old</span> <span class=o>:=</span> <span class=nx>new</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// If there are no waiters or a goroutine has already
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// been woken or grabbed the lock, no need to wake anyone.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// In starvation mode ownership is directly handed off from unlocking
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// goroutine to the next waiter. We are not part of this chain,
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// since we did not observe mutexStarving when we unlocked the mutex above.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// So get off the way.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// old 现在仅有 mutexWoken 位不确定，这里如果确定为 1，就直接退出，
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 代表有 P 中调度出的协程在 Lock 获取锁，不需要从 semaRoot 中调度协程
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=nx>old</span><span class=o>&gt;&gt;</span><span class=nx>mutexWaiterShift</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>old</span><span class=o>&amp;</span><span class=p>(</span><span class=nx>mutexLocked</span><span class=p>|</span><span class=nx>mutexWoken</span><span class=p>|</span><span class=nx>mutexStarving</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Grab the right to wake someone.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 没有 P 的协程，从队列中获取
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>new</span> <span class=p>=</span> <span class=p>(</span><span class=nx>old</span> <span class=o>-</span> <span class=mi>1</span><span class=o>&lt;&lt;</span><span class=nx>mutexWaiterShift</span><span class=p>)</span> <span class=p>|</span> <span class=nx>mutexWoken</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=nx>old</span><span class=p>,</span> <span class=nx>new</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>runtime_Semrelease</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>sema</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=nx>old</span> <span class=p>=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>state</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Starving mode: handoff mutex ownership to the next waiter, and yield
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// our time slice so that the next waiter can start to run immediately.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// Note: mutexLocked is not set, the waiter will set it after wakeup.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// But mutex is still considered locked if mutexStarving is set,
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// so new coming goroutines won&#39;t acquire it.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 饥饿模式，直接从 semaRoot 中获取，由于饥饿模式下，饥饿的协程 Lock 时会被放到队首
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>runtime_Semrelease</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>sema</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>首先看协程的状态 <code>awoke</code> 和 <code>staving</code>，一个协程第一次进入时，这两个状态都为 <code>false</code>。</p><h2 id=协程状态变化>协程状态变化</h2><p>协程状态变化都只在 <code>Lock</code> 调用时有用</p><h3 id=awoke><code>awoke</code></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// (lockSlow)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=nx>old</span><span class=o>&amp;</span><span class=p>(</span><span class=nx>mutexLocked</span><span class=p>|</span><span class=nx>mutexStarving</span><span class=p>)</span> <span class=o>==</span> <span class=nx>mutexLocked</span> <span class=o>&amp;&amp;</span> <span class=nf>runtime_canSpin</span><span class=p>(</span><span class=nx>iter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>!</span><span class=nx>awoke</span> <span class=o>&amp;&amp;</span> <span class=nx>old</span><span class=o>&amp;</span><span class=nx>mutexWoken</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>old</span><span class=o>&gt;&gt;</span><span class=nx>mutexWaiterShift</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>        <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=nx>old</span><span class=p>,</span> <span class=nx>old</span><span class=p>|</span><span class=nx>mutexWoken</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>awoke</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>转换过来说就是正常模式下仅有可以自旋的新的在 <code>P</code> 中被调度过来的协程可以进入</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// (lockSlow)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=nx>old</span><span class=p>,</span> <span class=nx>new</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>......</span>
</span></span><span class=line><span class=cl>    <span class=nx>awoke</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=nx>iter</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>old</span> <span class=p>=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>state</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>尝试获取锁的 <code>cas</code> 操作被成功执行后，无论协程是从 <code>P</code> 中还是 <code>semaRoot</code> 中调度出来的，只要第一次获取锁不成功后都将进入 <code>awoke</code></p><p>那么这样写有什么用呢？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// (lockSlow)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=nx>awoke</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>new</span><span class=o>&amp;</span><span class=nx>mutexWoken</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;sync: inconsistent mutex state&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>new</span> <span class=o>&amp;^=</span> <span class=nx>mutexWoken</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=nx>old</span><span class=p>,</span> <span class=nx>new</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// (unlockSlow)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=nx>old</span><span class=o>&gt;&gt;</span><span class=nx>mutexWaiterShift</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>old</span><span class=o>&amp;</span><span class=p>(</span><span class=nx>mutexLocked</span><span class=p>|</span><span class=nx>mutexWoken</span><span class=p>|</span><span class=nx>mutexStarving</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>一个从 <code>P</code> 调度出的协程，在 <code>Lock</code> 消除了锁的 <code>mutexWoken</code>，别的协程 <code>Unlock</code> 时会直接结束，不会从 <code>semaRoot</code> 中调度出其他协程，保证当前协程优先获得锁</p><h3 id=starving><code>starving</code></h3><p>协程是否 <code>staving</code> 只取决于当前协程等待锁的时间，比较简单</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// (lockSlow)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>queueLifo</span> <span class=o>:=</span> <span class=nx>waitStartTime</span> <span class=o>!=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>waitStartTime</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>waitStartTime</span> <span class=p>=</span> <span class=nf>runtime_nanotime</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>runtime_SemacquireMutex</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>sema</span><span class=p>,</span> <span class=nx>queueLifo</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>starving</span> <span class=p>=</span> <span class=nx>starving</span> <span class=o>||</span> <span class=nf>runtime_nanotime</span><span class=p>()</span><span class=o>-</span><span class=nx>waitStartTime</span> <span class=p>&gt;</span> <span class=nx>starvationThresholdNs</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=锁的状态变化>锁的状态变化</h2><h3 id=mutexlocked><code>mutexLocked</code></h3><p>置位 1 发生在尝试获取锁时，只要锁不是饥饿状态，那么获取锁无论成功与否，其都该为 1</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// (lockSlow)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=nx>old</span><span class=o>&amp;</span><span class=nx>mutexStarving</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>new</span> <span class=o>|=</span> <span class=nx>mutexLocked</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>置位 0 发生在解锁时</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// (Unlock)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>new</span> <span class=o>:=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>AddInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=o>-</span><span class=nx>mutexLocked</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=mutexwoken><code>mutexWoken</code></h3><p>置位 1 发生在解锁时，表明 <code>Unlock</code> 唤醒了一个队列中的协程；在加锁时表明当前协程是个唤醒的协程</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// (unlockSlow)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>new</span> <span class=p>=</span> <span class=p>(</span><span class=nx>old</span> <span class=o>-</span> <span class=mi>1</span><span class=o>&lt;&lt;</span><span class=nx>mutexWaiterShift</span><span class=p>)</span> <span class=p>|</span> <span class=nx>mutexWoken</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=nx>old</span><span class=p>,</span> <span class=nx>new</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>runtime_Semrelease</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>sema</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// (lockSlow)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=nx>old</span><span class=o>&amp;</span><span class=p>(</span><span class=nx>mutexLocked</span><span class=p>|</span><span class=nx>mutexStarving</span><span class=p>)</span> <span class=o>==</span> <span class=nx>mutexLocked</span> <span class=o>&amp;&amp;</span> <span class=nf>runtime_canSpin</span><span class=p>(</span><span class=nx>iter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>!</span><span class=nx>awoke</span> <span class=o>&amp;&amp;</span> <span class=nx>old</span><span class=o>&amp;</span><span class=nx>mutexWoken</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>old</span><span class=o>&gt;&gt;</span><span class=nx>mutexWaiterShift</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>        <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=nx>old</span><span class=p>,</span> <span class=nx>old</span><span class=p>|</span><span class=nx>mutexWoken</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>awoke</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>置位 0 发生在尝试获取锁时，表明当前协程是 <code>P</code> 中出来的，想要优先获取锁，别唤醒等待队列的协程</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// (lockSlow)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=nx>awoke</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// The goroutine has been woken from sleep,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// so we need to reset the flag in either case.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>new</span><span class=o>&amp;</span><span class=nx>mutexWoken</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;sync: inconsistent mutex state&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>new</span> <span class=o>&amp;^=</span> <span class=nx>mutexWoken</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=mutexstarving><code>mutexStarving</code></h3><p>置位 1 发生在获取锁时，当前协程饥饿且锁被锁定，置位通知其它协程莫要跟我抢</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// (lockSlow)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=nx>starving</span> <span class=o>&amp;&amp;</span> <span class=nx>old</span><span class=o>&amp;</span><span class=nx>mutexLocked</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>new</span> <span class=o>|=</span> <span class=nx>mutexStarving</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>置位 0 也是在获取锁时，当前协程不在饥饿状态但是锁在饥饿状态，或者当前协程是等待队列中最后一个时，都说明饥饿的协程没有了，锁的饥饿状态也要消失</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// (lockSlow)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=nx>old</span><span class=o>&amp;</span><span class=nx>mutexStarving</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>old</span><span class=o>&amp;</span><span class=p>(</span><span class=nx>mutexLocked</span><span class=p>|</span><span class=nx>mutexWoken</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>old</span><span class=o>&gt;&gt;</span><span class=nx>mutexWaiterShift</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;sync: inconsistent mutex state&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>delta</span> <span class=o>:=</span> <span class=nb>int32</span><span class=p>(</span><span class=nx>mutexLocked</span> <span class=o>-</span> <span class=mi>1</span><span class=o>&lt;&lt;</span><span class=nx>mutexWaiterShift</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>!</span><span class=nx>starving</span> <span class=o>||</span> <span class=nx>old</span><span class=o>&gt;&gt;</span><span class=nx>mutexWaiterShift</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>delta</span> <span class=o>-=</span> <span class=nx>mutexStarving</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>atomic</span><span class=p>.</span><span class=nf>AddInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=nx>delta</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=过程模拟>过程模拟</h1><p>假设多个个协程使用同一个锁的情形</p><ul><li>A 先加锁，直接获得锁</li><li>B 再加锁，进入自旋，由于等待队列空，所以协程不能是 <code>awoke</code>，自旋结束尝试获取锁，由于 A 没释放，当前协程放到信号量的调度队列中</li><li>C 加锁同时 A 解锁，此时 B 还在信号量调度中等待，C 可以进入 <code>awoke</code> 并设置锁 <code>mutexWoken = 1</code>，A 解锁时由于 <code>mutexWoken = 1</code> 直接返回，不唤醒协程 B，C 获得锁</li><li>之后 D E 加锁时，由于 <code>mutexWoken = 1</code>，所以不能 <code>awoke</code>，进入信号量等待队列</li><li>C 解锁，发现没有被唤醒的协程，只能从信号量中取，先是 B，假设此时已经超过最大等待时间，B 进入饥饿状态，B 会更新锁到饥饿状态并获得锁</li><li>F 要加锁，此时锁是饥饿状态，不自旋，直接尝试获取锁，此时正好 B 解锁，B 发现锁处于饥饿状态，直接唤醒 D 运行，F 自身不是饥饿状态，所以加入信号量队列</li><li>D 自己不饥饿，所以 D 加锁结束时使锁退出饥饿状态</li><li>D 解锁时 G 加锁，G 进入 <code>awoke</code>，D 直接退出使得 G 获取到锁，E，F 此时在信号量等待队列中</li></ul><p>观察上边的模拟可以知道</p><ul><li>信号量队列中的协程，同时只有一个会被唤醒，因为唤醒操作在解锁时，<code>Mutex</code> 是互斥锁，只能唤醒一个</li><li>从 <code>P</code> 中调度运行的协程，如果某个协程 A 进入 <code>awoke</code>，其他协程在 A 释放锁之前加锁一律会被放入信号量等待队列。如果没这个保证，其他协程也能进入 <code>awoke</code>，那么 <code>runtime_Semrelease</code> 永远不会被执行。</li></ul><h1 id=总结>总结</h1><h2 id=正常模式>正常模式</h2><ul><li>如果锁没被任何协程使用，直接 <code>cas</code> 加解锁成功</li><li>如果锁被使用，先自旋等待锁释放，之后尝试获取锁，如果当前协程是处于被唤醒状态，那么能优先获取到锁。如果尝试失败，则放入信号量等待调度，锁释放时，优先放给唤醒态的协程，再放给调度信号量内的协程。</li></ul><h2 id=饥饿模式>饥饿模式</h2><ul><li>加锁时不自旋，直接尝试获取锁</li><li>解锁时直接唤醒信号量队列内的协程</li></ul><h2 id=切换时机>切换时机</h2><ul><li>协程被信号量调度后，计算被调度的时间，时间超过一毫秒则协程进入饥饿模式，下一轮循环时设置锁进入饥饿模式。</li><li>锁进入饥饿模式，加锁最后退出时，如果协程不是饥饿模式或者当前协程就是等待者中的最后一个，那么退出饥饿模式</li></ul></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>intxff</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2023-11-05</span></p></div><footer class=post-footer><div class=post-tags><a href=/zh-cn/tags/mutex/>mutex</a>
<a href=/zh-cn/tags/go/>go</a>
<a href=/zh-cn/tags/%E9%94%81/>锁</a></div><nav class=post-nav><a class=prev href=/zh-cn/post/go-gmp-%E8%B0%83%E5%BA%A6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">Go GMP 调度源码分析</span>
<span class="prev-text nav-mobile">上一篇</span></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=http://localhost:1313 class="iconfont icon-github" title=github></a>
<a href=/zh-cn/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2023<span class=heart><i class="iconfont icon-heart"></i></span><span>intxff</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin=anonymous></script>
<script>var languageCode="zh-cn".replace(/-/g,"_").replace(/_(.*)/,function(e,t){return e.replace(t,t.toUpperCase())});timeago().render(document.querySelectorAll(".timeago"),languageCode),timeago.cancel()</script><script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script>
<script type=text/javascript>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script></body></html>