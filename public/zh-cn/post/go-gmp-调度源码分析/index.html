<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Go GMP 调度源码分析 - Tender Night</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="intxff"><meta name=description content="这篇文章不会采用列举各种状态变换之类的方式说明调度过程，目的是让读者能根据简短的操作说明(对，很简短，所以你要学下 gdb 调试的常用指令)，自己跟"><meta name=keywords content="Hugo,theme,even"><meta name=generator content="Hugo 0.114.0 with theme even"><link rel=canonical href=/zh-cn/post/go-gmp-%E8%B0%83%E5%BA%A6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Go GMP 调度源码分析"><meta property="og:description" content="这篇文章不会采用列举各种状态变换之类的方式说明调度过程，目的是让读者能根据简短的操作说明(对，很简短，所以你要学下 gdb 调试的常用指令)，自己跟"><meta property="og:type" content="article"><meta property="og:url" content="/zh-cn/post/go-gmp-%E8%B0%83%E5%BA%A6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-11-07T13:22:39+08:00"><meta property="article:modified_time" content="2023-11-07T13:22:39+08:00"><meta itemprop=name content="Go GMP 调度源码分析"><meta itemprop=description content="这篇文章不会采用列举各种状态变换之类的方式说明调度过程，目的是让读者能根据简短的操作说明(对，很简短，所以你要学下 gdb 调试的常用指令)，自己跟"><meta itemprop=datePublished content="2023-11-07T13:22:39+08:00"><meta itemprop=dateModified content="2023-11-07T13:22:39+08:00"><meta itemprop=wordCount content="17582"><meta itemprop=keywords content="go,gmp,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go GMP 调度源码分析"><meta name=twitter:description content="这篇文章不会采用列举各种状态变换之类的方式说明调度过程，目的是让读者能根据简短的操作说明(对，很简短，所以你要学下 gdb 调试的常用指令)，自己跟"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/zh-cn/ class=logo>Tender Night</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a></ul><div class=language-selector><ul class=languages-list><li class="language-item active"><a href=/zh-cn/post/go-gmp-%E8%B0%83%E5%BA%A6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>中文</a></li><li class=language-item><a href=/en-us/>EN</a></li></ul></div></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/zh-cn/ class=logo>Tender Night</a></div><div class=language-selector><ul class=languages-list><li class="language-item active"><a href=/zh-cn/post/go-gmp-%E8%B0%83%E5%BA%A6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>中文</a></li><li class=language-item><a href=/en-us/>EN</a></li></ul></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/zh-cn/>首页</a></li><li class=menu-item><a class=menu-item-link href=/zh-cn/post/>归档</a></li><li class=menu-item><a class=menu-item-link href=/zh-cn/tags/>标签</a></li><li class=menu-item><a class=menu-item-link href=/zh-cn/categories/>分类</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Go GMP 调度源码分析</h1><div class=post-meta><span class=post-time>2023-11-07</span><div class=post-category><a href=/zh-cn/categories/go-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>go 源码分析</a>
<a href=/zh-cn/categories/%E5%A4%8D%E8%AF%BB%E6%9C%BA/>复读机</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#调试跟踪>调试跟踪</a></li><li><a href=#进入运行时前的准备>进入运行时前的准备</a><ul><li><a href=#osinit><code>osinit</code></a></li><li><a href=#schedinit><code>schedinit</code></a></li><li><a href=#newproc><code>newproc</code></a></li><li><a href=#mstart><code>mstart</code></a></li></ul></li><li><a href=#m0-上开启第一次调度>m0 上开启第一次调度</a><ul><li><a href=#g-的创建><code>g</code> 的创建</a></li><li><a href=#怎么找到可执行的-g>怎么找到可执行的 <code>g</code></a></li><li><a href=#怎么开始执行-g>怎么开始执行 <code>g</code></a></li><li><a href=#怎么退出-g-并开启下次调度>怎么退出 <code>g</code> 并开启下次调度</a></li><li><a href=#回到第一个真正的-g>回到第一个真正的 <code>g</code></a></li><li><a href=#漏了什么怎么暂停-g-再开始>漏了什么？怎么暂停 <code>g</code> 再开始</a></li></ul></li><li><a href=#之后-m-的创建和调度>之后 <code>m</code> 的创建和调度</a><ul><li><a href=#m-的创建><code>m</code> 的创建</a></li><li><a href=#m-的调度><code>m</code> 的调度</a></li></ul></li><li><a href=#还要分析-p-吗>还要分析 <code>p</code> 吗</a></li><li><a href=#关于抢占式调度>关于抢占式调度</a></li></ul></nav></div></div><div class=post-content><p>这篇文章不会采用列举各种状态变换之类的方式说明调度过程，目的是让读者能根据简短的操作说明(对，很简短，所以你要学下 gdb 调试的常用指令)，自己跟踪调试出程序从 0 到 1 的整个调度运行过程，文章的大量源码注解，是你在没思路和验证自己分析时的辅助，当然，我的分析也不一定百分百正确，欢迎指正。直到第二个 <code>m</code> 的创建和调度结束前，行文都按照调试的顺序书写，这之后由于运行时开始并发运行，不好调试得到，所以其他触发调度的情况就仅仅是阅读代码的总结。</p><h1 id=调试跟踪>调试跟踪</h1><p>由于要跟踪 go 程序的 <code>gmp</code> 调度，使用 dlv 办不到，dlv 会直接从用户代码开始，所以这里使用 gdb 调试。</p><p>二进制程序根据系统平台有专有的固定格式，linux 下是 <code>ELF</code> 文件格式，<code>ELF</code> 中的 <code>E_ENTRY</code> 字段确定了加载后执行程序开始的虚拟地址的位置。这里使用编译后的 <code>main</code> 文件作为演示</p><ul><li>进入 gdb 调试</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>gdb main
</span></span></code></pre></td></tr></table></div></div><ul><li>找到程序入口，并设置断点</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> info files
</span></span><span class=line><span class=cl>Symbols from <span class=s2>&#34;main&#34;</span>.
</span></span><span class=line><span class=cl>Local <span class=nb>exec</span> file:
</span></span><span class=line><span class=cl>        <span class=sb>`</span>main<span class=err>&#39;</span>, file <span class=nb>type</span> elf64-x86-64.
</span></span><span class=line><span class=cl>        Entry point: 0x455ea0
</span></span><span class=line><span class=cl>        0x0000000000401000 - 0x000000000045775e is .text
</span></span><span class=line><span class=cl>        0x0000000000458000 - 0x000000000047f184 is .rodata
</span></span><span class=line><span class=cl>        0x000000000047f2c0 - 0x000000000047f5f4 is .typelink
</span></span><span class=line><span class=cl>        0x000000000047f5f8 - 0x000000000047f600 is .itablink
</span></span><span class=line><span class=cl>        0x000000000047f600 - 0x000000000047f600 is .gosymtab
</span></span><span class=line><span class=cl>        0x000000000047f600 - 0x00000000004c5d38 is .gopclntab
</span></span><span class=line><span class=cl>        0x00000000004c6000 - 0x00000000004c6140 is .go.buildinfo
</span></span><span class=line><span class=cl>        0x00000000004c6140 - 0x00000000004c72a0 is .noptrdata
</span></span><span class=line><span class=cl>        0x00000000004c72a0 - 0x00000000004c9930 is .data
</span></span><span class=line><span class=cl>        0x00000000004c9940 - 0x00000000004f75b8 is .bss
</span></span><span class=line><span class=cl>        0x00000000004f75c0 - 0x00000000004fb3b0 is .noptrbss
</span></span><span class=line><span class=cl>        0x0000000000400f9c - 0x0000000000401000 is .note.go.buildid
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> b *0x455ea0
</span></span><span class=line><span class=cl>Breakpoint <span class=m>1</span> at 0x455ea0: file /usr/lib/go/src/runtime/rt0_linux_amd64.s, line 8.
</span></span></code></pre></td></tr></table></div></div><blockquote><ul><li>如果 gdb 内部找不到入口点，可以使用 <code>readelf -h main</code> 查看</li><li>如果 gdb 版本比较新，<code>starti</code> 指令可以直接从入口点开始执行</li></ul></blockquote><ul><li>启动程序，这样就可以在 <code>gmp</code> 调度启动前调试了</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> run
</span></span></code></pre></td></tr></table></div></div><h1 id=进入运行时前的准备>进入运行时前的准备</h1><ul><li>先为 <code>g0</code> 结构体初始化其栈地址，根据代码可知 <code>g0</code> 的栈是在系统栈空间上。</li><li>再为 <code>m0</code> 初始化 <code>tls</code> 指向实际 <code>TLS</code> 伪寄存器的值，将 <code>g0</code> 和 <code>m0</code> 双向绑定</li></ul><blockquote><ul><li><code>g0</code> <code>m0</code> 都是全局静态变量，可以在 ELF 查到属性为 <code>GLOBAL</code> 的符号，其所在的虚拟地址空间范围一开始就已经存在，但是尚未分配实际内存并初始化</li><li>用户代码中说到栈一般指 go 运行时的栈，这个栈是 go 运行时对系统堆进行再次划分得到的，不是通常意义说的ELF 文件定义的栈空间，go 源码里会单独指出 <code>system stack</code>，系统栈特指 ELF 定义的栈。go 用户代码里的栈和堆，不特别说明，其实都是 ELF 定义的堆。不过，栈和堆都是概念性的东西，知道其对应关系和管理方式不同就行</li><li><code>TLS</code> 伪寄存器实际是线程上某一内存空间，具体是哪块我没细究，<code>TLS</code> 用于存储当前运行的 <code>g</code> 的结构体，方便快速查找</li></ul></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=c1>// [runtime/asm_amd64.s]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>TEXT</span> <span class=no>runtime</span><span class=err>·</span><span class=no>rt0_go</span><span class=p>(</span><span class=no>SB</span><span class=p>),</span><span class=no>NOSPLIT</span><span class=err>|</span><span class=no>NOFRAME</span><span class=err>|</span><span class=no>TOPFRAME</span><span class=p>,</span><span class=no>$0</span>
</span></span><span class=line><span class=cl>	<span class=c1>// copy arguments forward on an even stack
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>MOVQ</span>	<span class=no>DI</span><span class=p>,</span> <span class=no>AX</span>		<span class=c1>// argc
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>MOVQ</span>	<span class=no>SI</span><span class=p>,</span> <span class=no>BX</span>		<span class=c1>// argv
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>SUBQ</span>	<span class=no>$</span><span class=p>(</span><span class=mi>5</span><span class=p>*</span><span class=mi>8</span><span class=p>),</span> <span class=no>SP</span>		<span class=c1>// 3args 2auto
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>ANDQ</span>	<span class=no>$</span><span class=err>~</span><span class=mi>15</span><span class=p>,</span> <span class=no>SP</span>
</span></span><span class=line><span class=cl>	<span class=nf>MOVQ</span>	<span class=no>AX</span><span class=p>,</span> <span class=mi>24</span><span class=p>(</span><span class=no>SP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>MOVQ</span>	<span class=no>BX</span><span class=p>,</span> <span class=mi>32</span><span class=p>(</span><span class=no>SP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// create istack out of the given (operating system) stack.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// _cgo_init may update stackguard.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>MOVQ</span>	<span class=no>$runtime</span><span class=err>·</span><span class=no>g0</span><span class=p>(</span><span class=no>SB</span><span class=p>),</span> <span class=no>DI</span>             <span class=c1>// DI = g0
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>LEAQ</span>	<span class=p>(-</span><span class=mi>64</span><span class=p>*</span><span class=mi>1024</span><span class=p>)(</span><span class=no>SP</span><span class=p>),</span> <span class=no>BX</span>              <span class=c1>// BX = SP - 64*1024
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>MOVQ</span>	<span class=no>BX</span><span class=p>,</span> <span class=no>g_stackguard0</span><span class=p>(</span><span class=no>DI</span><span class=p>)</span>           <span class=c1>// g0.stackguard0 = BX
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>MOVQ</span>	<span class=no>BX</span><span class=p>,</span> <span class=no>g_stackguard1</span><span class=p>(</span><span class=no>DI</span><span class=p>)</span>           <span class=c1>// g0.stackguard1 = BX
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>MOVQ</span>	<span class=no>BX</span><span class=p>,</span> <span class=p>(</span><span class=no>g_stack</span><span class=err>+</span><span class=no>stack_lo</span><span class=p>)(</span><span class=no>DI</span><span class=p>)</span>      <span class=c1>// g0.stack.lo = BX
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>MOVQ</span>	<span class=no>SP</span><span class=p>,</span> <span class=p>(</span><span class=no>g_stack</span><span class=err>+</span><span class=no>stack_hi</span><span class=p>)(</span><span class=no>DI</span><span class=p>)</span>      <span class=c1>// g0.stack.hi = SP lo 和 hi 确定了栈大小 64 k
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=na>......</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nl>needtls:</span>
</span></span><span class=line><span class=cl>    <span class=na>......</span>
</span></span><span class=line><span class=cl>	<span class=nf>LEAQ</span>	<span class=no>runtime</span><span class=err>·</span><span class=no>m0</span><span class=err>+</span><span class=no>m_tls</span><span class=p>(</span><span class=no>SB</span><span class=p>),</span> <span class=no>DI</span>        <span class=c1>// DI = &amp;(m0.tls)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>CALL</span>	<span class=no>runtime</span><span class=err>·</span><span class=no>settls</span><span class=p>(</span><span class=no>SB</span><span class=p>)</span>              <span class=c1>// m0.tls = TLS，settls 定义在 [runtime/sys_linux_amd64.s]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// store through it, to make sure it works
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>get_tls</span><span class=p>(</span><span class=no>BX</span><span class=p>)</span>                             <span class=c1>// BX = TLS，get_tls 定义在 [runtime/go_tls.h]
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>MOVQ</span>	<span class=no>$0x123</span><span class=p>,</span> <span class=no>g</span><span class=p>(</span><span class=no>BX</span><span class=p>)</span>                   <span class=c1>// TLS.g = 0x123
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>MOVQ</span>	<span class=no>runtime</span><span class=err>·</span><span class=no>m0</span><span class=err>+</span><span class=no>m_tls</span><span class=p>(</span><span class=no>SB</span><span class=p>),</span> <span class=no>AX</span>        <span class=c1>// AX = m0.tls
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>CMPQ</span>	<span class=no>AX</span><span class=p>,</span> <span class=no>$0x123</span>                      <span class=c1>// AX == 0x123，测试之前绑定 m0.tls 到 TLS 是否正确
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>JEQ</span> <span class=mi>2</span><span class=p>(</span><span class=no>PC</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>CALL</span>	<span class=no>runtime</span><span class=err>·</span><span class=no>abort</span><span class=p>(</span><span class=no>SB</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nl>ok:</span>
</span></span><span class=line><span class=cl>	<span class=c1>// set the per-goroutine and per-mach &#34;registers&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>get_tls</span><span class=p>(</span><span class=no>BX</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>LEAQ</span>	<span class=no>runtime</span><span class=err>·</span><span class=no>g0</span><span class=p>(</span><span class=no>SB</span><span class=p>),</span> <span class=no>CX</span>              <span class=c1>// CX = g0
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>MOVQ</span>	<span class=no>CX</span><span class=p>,</span> <span class=no>g</span><span class=p>(</span><span class=no>BX</span><span class=p>)</span>                       <span class=c1>// TLS.g = g0
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>LEAQ</span>	<span class=no>runtime</span><span class=err>·</span><span class=no>m0</span><span class=p>(</span><span class=no>SB</span><span class=p>),</span> <span class=no>AX</span>              <span class=c1>// AX = &amp;m0
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// save m-&gt;g0 = g0
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>MOVQ</span>	<span class=no>CX</span><span class=p>,</span> <span class=no>m_g0</span><span class=p>(</span><span class=no>AX</span><span class=p>)</span>                    <span class=c1>// m0.g0 = g0
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// save m0 to g0-&gt;m
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>MOVQ</span>	<span class=no>AX</span><span class=p>,</span> <span class=no>g_m</span><span class=p>(</span><span class=no>CX</span><span class=p>)</span>                     <span class=c1>// g0.m = m0 双向绑定
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nf>CLD</span>				<span class=c1>// convention is D is always left cleared
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=na>......</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>CALL</span>	<span class=no>runtime</span><span class=err>·</span><span class=no>check</span><span class=p>(</span><span class=no>SB</span><span class=p>)</span> <span class=c1>// 定义在 [runtime/runtime1.go]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nf>MOVL</span>	<span class=mi>24</span><span class=p>(</span><span class=no>SP</span><span class=p>),</span> <span class=no>AX</span>		<span class=c1>// copy argc
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>MOVL</span>	<span class=no>AX</span><span class=p>,</span> <span class=mi>0</span><span class=p>(</span><span class=no>SP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>MOVQ</span>	<span class=mi>32</span><span class=p>(</span><span class=no>SP</span><span class=p>),</span> <span class=no>AX</span>		<span class=c1>// copy argv
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>MOVQ</span>	<span class=no>AX</span><span class=p>,</span> <span class=mi>8</span><span class=p>(</span><span class=no>SP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>CALL</span>	<span class=no>runtime</span><span class=err>·</span><span class=no>args</span><span class=p>(</span><span class=no>SB</span><span class=p>)</span> <span class=c1>// [runtime/runtime1.go]
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>CALL</span>	<span class=no>runtime</span><span class=err>·</span><span class=no>osinit</span><span class=p>(</span><span class=no>SB</span><span class=p>)</span> <span class=c1>// [runtime/os_linux.go]
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>CALL</span>	<span class=no>runtime</span><span class=err>·</span><span class=no>schedinit</span><span class=p>(</span><span class=no>SB</span><span class=p>)</span> <span class=c1>// [runtime/proc.go]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// create a new goroutine to start program
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>MOVQ</span>	<span class=no>$runtime</span><span class=err>·</span><span class=no>mainPC</span><span class=p>(</span><span class=no>SB</span><span class=p>),</span> <span class=no>AX</span>		<span class=c1>// entry // 定义在本文件，指向 [runtime/proc.go] 的 main 函数，这里放到 AX 等待作为参数被 newproc 调用
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>PUSHQ</span>	<span class=no>AX</span>
</span></span><span class=line><span class=cl>	<span class=nf>CALL</span>	<span class=no>runtime</span><span class=err>·</span><span class=no>newproc</span><span class=p>(</span><span class=no>SB</span><span class=p>)</span> <span class=c1>// [runtime/proc.go]
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>POPQ</span>	<span class=no>AX</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// start this M
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>CALL</span>	<span class=no>runtime</span><span class=err>·</span><span class=no>mstart</span><span class=p>(</span><span class=no>SB</span><span class=p>)</span> <span class=c1>// [runtime/proc.go]，实际实现是放在 [runtime/asm_amd64.s]，mstart 调用 mstart0
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nf>CALL</span>	<span class=no>runtime</span><span class=err>·</span><span class=no>abort</span><span class=p>(</span><span class=no>SB</span><span class=p>)</span>	<span class=c1>// mstart should never return // 说明到这之前就完全进入运行时了
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>RET</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=osinit><code>osinit</code></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// [runtime/os_linux.go]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>osinit</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ncpu</span> <span class=p>=</span> <span class=nf>getproccount</span><span class=p>()</span> <span class=c1>// 初始化 ncpu，为之后生成 P 使用
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>physHugePageSize</span> <span class=p>=</span> <span class=nf>getHugePageSize</span><span class=p>()</span> <span class=c1>// 初始化 physHugePageSize
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>osArchInit</span><span class=p>()</span> <span class=c1>// linux 下这个就是空函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=schedinit><code>schedinit</code></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span><span class=lnt>195
</span><span class=lnt>196
</span><span class=lnt>197
</span><span class=lnt>198
</span><span class=lnt>199
</span><span class=lnt>200
</span><span class=lnt>201
</span><span class=lnt>202
</span><span class=lnt>203
</span><span class=lnt>204
</span><span class=lnt>205
</span><span class=lnt>206
</span><span class=lnt>207
</span><span class=lnt>208
</span><span class=lnt>209
</span><span class=lnt>210
</span><span class=lnt>211
</span><span class=lnt>212
</span><span class=lnt>213
</span><span class=lnt>214
</span><span class=lnt>215
</span><span class=lnt>216
</span><span class=lnt>217
</span><span class=lnt>218
</span><span class=lnt>219
</span><span class=lnt>220
</span><span class=lnt>221
</span><span class=lnt>222
</span><span class=lnt>223
</span><span class=lnt>224
</span><span class=lnt>225
</span><span class=lnt>226
</span><span class=lnt>227
</span><span class=lnt>228
</span><span class=lnt>229
</span><span class=lnt>230
</span><span class=lnt>231
</span><span class=lnt>232
</span><span class=lnt>233
</span><span class=lnt>234
</span><span class=lnt>235
</span><span class=lnt>236
</span><span class=lnt>237
</span><span class=lnt>238
</span><span class=lnt>239
</span><span class=lnt>240
</span><span class=lnt>241
</span><span class=lnt>242
</span><span class=lnt>243
</span><span class=lnt>244
</span><span class=lnt>245
</span><span class=lnt>246
</span><span class=lnt>247
</span><span class=lnt>248
</span><span class=lnt>249
</span><span class=lnt>250
</span><span class=lnt>251
</span><span class=lnt>252
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// [runtime/proc.go]
</span></span></span><span class=line><span class=cl><span class=c1>// The bootstrap sequence is:
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//	call osinit
</span></span></span><span class=line><span class=cl><span class=c1>//	call schedinit
</span></span></span><span class=line><span class=cl><span class=c1>//	make &amp; queue new G
</span></span></span><span class=line><span class=cl><span class=c1>//	call runtime·mstart
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// The new G calls runtime·main.
</span></span></span><span class=line><span class=cl><span class=c1>// 官方的注释跟分析结果一致 😊
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>schedinit</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 各种全局资源的锁初始化，这里的资源很多，有调度相关的，有调试跟踪相关的，可以作为分析的切入点
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>,</span> <span class=nx>lockRankSched</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>sysmonlock</span><span class=p>,</span> <span class=nx>lockRankSysmon</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>deferlock</span><span class=p>,</span> <span class=nx>lockRankDefer</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>sudoglock</span><span class=p>,</span> <span class=nx>lockRankSudog</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>deadlock</span><span class=p>,</span> <span class=nx>lockRankDeadlock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>paniclk</span><span class=p>,</span> <span class=nx>lockRankPanic</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>allglock</span><span class=p>,</span> <span class=nx>lockRankAllg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>allpLock</span><span class=p>,</span> <span class=nx>lockRankAllp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>reflectOffs</span><span class=p>.</span><span class=nx>lock</span><span class=p>,</span> <span class=nx>lockRankReflectOffs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>finlock</span><span class=p>,</span> <span class=nx>lockRankFin</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>trace</span><span class=p>.</span><span class=nx>bufLock</span><span class=p>,</span> <span class=nx>lockRankTraceBuf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>trace</span><span class=p>.</span><span class=nx>stringsLock</span><span class=p>,</span> <span class=nx>lockRankTraceStrings</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>trace</span><span class=p>.</span><span class=nx>lock</span><span class=p>,</span> <span class=nx>lockRankTrace</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>cpuprof</span><span class=p>.</span><span class=nx>lock</span><span class=p>,</span> <span class=nx>lockRankCpuprof</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>trace</span><span class=p>.</span><span class=nx>stackTab</span><span class=p>.</span><span class=nx>lock</span><span class=p>,</span> <span class=nx>lockRankTraceStackTab</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Enforce that this lock is always a leaf lock.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// All of this lock&#39;s critical sections should be
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// extremely short.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>memstats</span><span class=p>.</span><span class=nx>heapStats</span><span class=p>.</span><span class=nx>noPLock</span><span class=p>,</span> <span class=nx>lockRankLeafRank</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// raceinit must be the first call to race detector.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// In particular, it must be done before mallocinit below calls racemapshadow.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>gp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>()</span> <span class=c1>// 从 TLS 获取当前正在运行的 g，gp = pointer of g
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>raceenabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>gp</span><span class=p>.</span><span class=nx>racectx</span><span class=p>,</span> <span class=nx>raceprocctx0</span> <span class=p>=</span> <span class=nf>raceinit</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>sched</span><span class=p>.</span><span class=nx>maxmcount</span> <span class=p>=</span> <span class=mi>10000</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// The world starts stopped.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>worldStopped</span><span class=p>()</span> <span class=c1>// 由于非 debug 模式时，lockrank 关闭，所以这里是空函数；lockrank 是为了检测死锁用
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nf>moduledataverify</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nf>stackinit</span><span class=p>()</span> <span class=c1>// 全局 stackpool 初始化，有两个池，还有个 stackLarge
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>mallocinit</span><span class=p>()</span> <span class=c1>// 全局 mheap 和 mcache0 初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>cpuinit</span><span class=p>()</span>      <span class=c1>// must run before alginit
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>alginit</span><span class=p>()</span>      <span class=c1>// maps, hash, fastrand must not be used before this call
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>fastrandinit</span><span class=p>()</span> <span class=c1>// must run before mcommoninit
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>mcommoninit</span><span class=p>(</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=c1>// 为 m0 分配 id，初始化 m0.gsignal 及 m0.goSigStack，m0.alllink = allm
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>modulesinit</span><span class=p>()</span>   <span class=c1>// provides activeModules
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>typelinksinit</span><span class=p>()</span> <span class=c1>// uses maps, activeModules
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>itabsinit</span><span class=p>()</span>     <span class=c1>// uses activeModules
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>stkobjinit</span><span class=p>()</span>    <span class=c1>// must run before GC starts
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nf>sigsave</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>sigmask</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>initSigmask</span> <span class=p>=</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>sigmask</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>goargs</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nf>goenvs</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nf>parsedebugvars</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nf>gcinit</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>sched</span><span class=p>.</span><span class=nx>lastpoll</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=nf>nanotime</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 设定 P 的数量
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>procs</span> <span class=o>:=</span> <span class=nx>ncpu</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nf>atoi32</span><span class=p>(</span><span class=nf>gogetenv</span><span class=p>(</span><span class=s>&#34;GOMAXPROCS&#34;</span><span class=p>));</span> <span class=nx>ok</span> <span class=o>&amp;&amp;</span> <span class=nx>n</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>procs</span> <span class=p>=</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nf>procresize</span><span class=p>(</span><span class=nx>procs</span><span class=p>)</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span> <span class=c1>// procresize 比外表复杂，下面有分析，P 也就是在这里创建
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;unknown runnable goroutine during bootstrap&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// World is effectively started now, as P&#39;s can run.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>worldStarted</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// For cgocheck &gt; 1, we turn on the write barrier at all times
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// and check all pointer writes. We can&#39;t do this until after
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// procresize because the write barrier needs a P.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>debug</span><span class=p>.</span><span class=nx>cgocheck</span> <span class=p>&gt;</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>writeBarrier</span><span class=p>.</span><span class=nx>cgo</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=nx>writeBarrier</span><span class=p>.</span><span class=nx>enabled</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>pp</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>allp</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>pp</span><span class=p>.</span><span class=nx>wbBuf</span><span class=p>.</span><span class=nf>reset</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>buildVersion</span> <span class=o>==</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Condition should never trigger. This code just serves
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// to ensure runtime·buildVersion is kept in the resulting binary.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>buildVersion</span> <span class=p>=</span> <span class=s>&#34;unknown&#34;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>modinfo</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Condition should never trigger. This code just serves
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// to ensure runtime·modinfo is kept in the resulting binary.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>modinfo</span> <span class=p>=</span> <span class=s>&#34;&#34;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Change number of processors.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// sched.lock must be held, and the world must be stopped.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// gcworkbufs must not be being modified by either the GC or the write barrier
</span></span></span><span class=line><span class=cl><span class=c1>// code, so the GC must not be running if the number of Ps actually changes.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Returns list of Ps with local work, they need to be scheduled by the caller.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>procresize</span><span class=p>(</span><span class=nx>nprocs</span> <span class=kt>int32</span><span class=p>)</span> <span class=o>*</span><span class=nx>p</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>assertLockHeld</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>assertWorldStopped</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>old</span> <span class=o>:=</span> <span class=nx>gomaxprocs</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>old</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>nprocs</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;procresize: invalid arg&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>trace</span><span class=p>.</span><span class=nx>enabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>traceGomaxprocs</span><span class=p>(</span><span class=nx>nprocs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// update statistics
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>now</span> <span class=o>:=</span> <span class=nf>nanotime</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>procresizetime</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>sched</span><span class=p>.</span><span class=nx>totaltime</span> <span class=o>+=</span> <span class=nb>int64</span><span class=p>(</span><span class=nx>old</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=nx>now</span> <span class=o>-</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>procresizetime</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>sched</span><span class=p>.</span><span class=nx>procresizetime</span> <span class=p>=</span> <span class=nx>now</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>maskWords</span> <span class=o>:=</span> <span class=p>(</span><span class=nx>nprocs</span> <span class=o>+</span> <span class=mi>31</span><span class=p>)</span> <span class=o>/</span> <span class=mi>32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Grow allp if necessary.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 新大小比全局的大小多，扩容 allp
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>nprocs</span> <span class=p>&gt;</span> <span class=nb>int32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>allp</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Synchronize with retake, which could be running
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// concurrently since it doesn&#39;t run on a P.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>allpLock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>nprocs</span> <span class=o>&lt;=</span> <span class=nb>int32</span><span class=p>(</span><span class=nb>cap</span><span class=p>(</span><span class=nx>allp</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>allp</span> <span class=p>=</span> <span class=nx>allp</span><span class=p>[:</span><span class=nx>nprocs</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>nallp</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=o>*</span><span class=nx>p</span><span class=p>,</span> <span class=nx>nprocs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=c1>// Copy everything up to allp&#39;s cap so we
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// never lose old allocated Ps.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nb>copy</span><span class=p>(</span><span class=nx>nallp</span><span class=p>,</span> <span class=nx>allp</span><span class=p>[:</span><span class=nb>cap</span><span class=p>(</span><span class=nx>allp</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>			<span class=nx>allp</span> <span class=p>=</span> <span class=nx>nallp</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>maskWords</span> <span class=o>&lt;=</span> <span class=nb>int32</span><span class=p>(</span><span class=nb>cap</span><span class=p>(</span><span class=nx>idlepMask</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>idlepMask</span> <span class=p>=</span> <span class=nx>idlepMask</span><span class=p>[:</span><span class=nx>maskWords</span><span class=p>]</span>
</span></span><span class=line><span class=cl>			<span class=nx>timerpMask</span> <span class=p>=</span> <span class=nx>timerpMask</span><span class=p>[:</span><span class=nx>maskWords</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>nidlepMask</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>uint32</span><span class=p>,</span> <span class=nx>maskWords</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=c1>// No need to copy beyond len, old Ps are irrelevant.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nb>copy</span><span class=p>(</span><span class=nx>nidlepMask</span><span class=p>,</span> <span class=nx>idlepMask</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>idlepMask</span> <span class=p>=</span> <span class=nx>nidlepMask</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nx>ntimerpMask</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>uint32</span><span class=p>,</span> <span class=nx>maskWords</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nb>copy</span><span class=p>(</span><span class=nx>ntimerpMask</span><span class=p>,</span> <span class=nx>timerpMask</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>timerpMask</span> <span class=p>=</span> <span class=nx>ntimerpMask</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>allpLock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// initialize new P&#39;s
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 如果扩容了，为 allp 生成少的 P
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>old</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>nprocs</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>pp</span> <span class=o>:=</span> <span class=nx>allp</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>pp</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>pp</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>pp</span><span class=p>.</span><span class=nf>init</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>atomicstorep</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>allp</span><span class=p>[</span><span class=nx>i</span><span class=p>]),</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>pp</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 也有可能缩容，原来使用的 P 可能作废，需要给这些 M 重新调度分配 P
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 现在在启动阶段，m0.p 是 0，所以这里也为 m0 添加了 p
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>().</span><span class=nx>id</span> <span class=p>&lt;</span> <span class=nx>nprocs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// continue to use the current P
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>().</span><span class=nx>status</span> <span class=p>=</span> <span class=nx>_Prunning</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 虽然继续使用 P，但是 mcache 被清空了，不太理解
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>().</span><span class=nx>mcache</span><span class=p>.</span><span class=nf>prepareForSweep</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// release the current P and acquire allp[0].
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// We must do this before destroying our current P
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// because p.destroy itself has write barriers, so we
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// need to do that from a valid P.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>trace</span><span class=p>.</span><span class=nx>enabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=c1>// Pretend that we were descheduled
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// and then scheduled again to keep
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// the trace sane.
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=nf>traceGoSched</span><span class=p>()</span>
</span></span><span class=line><span class=cl>				<span class=nf>traceProcStop</span><span class=p>(</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>())</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>().</span><span class=nx>m</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>		<span class=nx>pp</span> <span class=o>:=</span> <span class=nx>allp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=nx>pp</span><span class=p>.</span><span class=nx>m</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>		<span class=nx>pp</span><span class=p>.</span><span class=nx>status</span> <span class=p>=</span> <span class=nx>_Pidle</span>
</span></span><span class=line><span class=cl>		<span class=nf>acquirep</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span> <span class=c1>// 双向绑定 M 和 P
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>trace</span><span class=p>.</span><span class=nx>enabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>traceGoStart</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// g.m.p is now set, so we no longer need mcache0 for bootstrapping.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>mcache0</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// release resources from unused P&#39;s
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>nprocs</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>old</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>pp</span> <span class=o>:=</span> <span class=nx>allp</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=nx>pp</span><span class=p>.</span><span class=nf>destroy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=c1>// can&#39;t free P itself because it can be referenced by an M in syscall
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Trim allp.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nb>int32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>allp</span><span class=p>))</span> <span class=o>!=</span> <span class=nx>nprocs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>allpLock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>allp</span> <span class=p>=</span> <span class=nx>allp</span><span class=p>[:</span><span class=nx>nprocs</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=nx>idlepMask</span> <span class=p>=</span> <span class=nx>idlepMask</span><span class=p>[:</span><span class=nx>maskWords</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=nx>timerpMask</span> <span class=p>=</span> <span class=nx>timerpMask</span><span class=p>[:</span><span class=nx>maskWords</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>allpLock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 把 allp 中未使用的 P 设为 Pidle 状态
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kd>var</span> <span class=nx>runnablePs</span> <span class=o>*</span><span class=nx>p</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>nprocs</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=o>--</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>pp</span> <span class=o>:=</span> <span class=nx>allp</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span> <span class=o>==</span> <span class=nx>pp</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>pp</span><span class=p>.</span><span class=nx>status</span> <span class=p>=</span> <span class=nx>_Pidle</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nf>runqempty</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>pidleput</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span> <span class=nx>now</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>pp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nf>set</span><span class=p>(</span><span class=nf>mget</span><span class=p>())</span> <span class=c1>// 启动时 sched.midle 为空，所以这些 p 并没有绑定 m
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>pp</span><span class=p>.</span><span class=nx>link</span><span class=p>.</span><span class=nf>set</span><span class=p>(</span><span class=nx>runnablePs</span><span class=p>)</span> <span class=c1>// link 指向自己
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>runnablePs</span> <span class=p>=</span> <span class=nx>pp</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>stealOrder</span><span class=p>.</span><span class=nf>reset</span><span class=p>(</span><span class=nb>uint32</span><span class=p>(</span><span class=nx>nprocs</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>int32p</span> <span class=o>*</span><span class=kt>int32</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>gomaxprocs</span> <span class=c1>// make compiler check that gomaxprocs is an int32
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>atomic</span><span class=p>.</span><span class=nf>Store</span><span class=p>((</span><span class=o>*</span><span class=kt>uint32</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>int32p</span><span class=p>)),</span> <span class=nb>uint32</span><span class=p>(</span><span class=nx>nprocs</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>old</span> <span class=o>!=</span> <span class=nx>nprocs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Notify the limiter that the amount of procs has changed.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>gcCPULimiter</span><span class=p>.</span><span class=nf>resetCapacity</span><span class=p>(</span><span class=nx>now</span><span class=p>,</span> <span class=nx>nprocs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>runnablePs</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>到这里知道了 <code>P</code> 是在 <code>m0</code> <code>g0</code> 初始化完成后，先创建了 <code>allp</code>，再从其中选出第一个 <code>P</code> 给 <code>m0</code></p><h2 id=newproc><code>newproc</code></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span><span class=lnt>195
</span><span class=lnt>196
</span><span class=lnt>197
</span><span class=lnt>198
</span><span class=lnt>199
</span><span class=lnt>200
</span><span class=lnt>201
</span><span class=lnt>202
</span><span class=lnt>203
</span><span class=lnt>204
</span><span class=lnt>205
</span><span class=lnt>206
</span><span class=lnt>207
</span><span class=lnt>208
</span><span class=lnt>209
</span><span class=lnt>210
</span><span class=lnt>211
</span><span class=lnt>212
</span><span class=lnt>213
</span><span class=lnt>214
</span><span class=lnt>215
</span><span class=lnt>216
</span><span class=lnt>217
</span><span class=lnt>218
</span><span class=lnt>219
</span><span class=lnt>220
</span><span class=lnt>221
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// [runtime/proc.go]
</span></span></span><span class=line><span class=cl><span class=c1>// Create a new g running fn.
</span></span></span><span class=line><span class=cl><span class=c1>// Put it on the queue of g&#39;s waiting to run.
</span></span></span><span class=line><span class=cl><span class=c1>// The compiler turns a go statement into a call to this.
</span></span></span><span class=line><span class=cl><span class=c1>// 用户代码中的 go func 就会转化为这样
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>newproc</span><span class=p>(</span><span class=nx>fn</span> <span class=o>*</span><span class=nx>funcval</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>pc</span> <span class=o>:=</span> <span class=nf>getcallerpc</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// systemstack 分析在后边
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// func 匿名函数在 g0 栈上执行，辅助创建新的 g
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>systemstack</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>newg</span> <span class=o>:=</span> <span class=nf>newproc1</span><span class=p>(</span><span class=nx>fn</span><span class=p>,</span> <span class=nx>gp</span><span class=p>,</span> <span class=nx>pc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>pp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>().</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nf>runqput</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span> <span class=nx>newg</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span> <span class=c1>// newg 处于 Grunable 状态，加入当前 g 所在 p 的 runnext 中，原来在 runnext 中的 g 会被强行放到 runq 中去
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>mainStarted</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>wakep</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Create a new g in state _Grunnable, starting at fn. callerpc is the
</span></span></span><span class=line><span class=cl><span class=c1>// address of the go statement that created this. The caller is responsible
</span></span></span><span class=line><span class=cl><span class=c1>// for adding the new g to the scheduler.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>newproc1</span><span class=p>(</span><span class=nx>fn</span> <span class=o>*</span><span class=nx>funcval</span><span class=p>,</span> <span class=nx>callergp</span> <span class=o>*</span><span class=nx>g</span><span class=p>,</span> <span class=nx>callerpc</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=o>*</span><span class=nx>g</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>fn</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>fatal</span><span class=p>(</span><span class=s>&#34;go of nil func value&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 锁定 m
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>mp</span> <span class=o>:=</span> <span class=nf>acquirem</span><span class=p>()</span> <span class=c1>// disable preemption because we hold M and P in local vars.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>pp</span> <span class=o>:=</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 从 p.gFree 中获取 g 结构体，好处是不用重新分配，加速加速
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>newg</span> <span class=o>:=</span> <span class=nf>gfget</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>newg</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 重新分配 g
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>newg</span> <span class=p>=</span> <span class=nf>malg</span><span class=p>(</span><span class=nx>stackMin</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>casgstatus</span><span class=p>(</span><span class=nx>newg</span><span class=p>,</span> <span class=nx>_Gidle</span><span class=p>,</span> <span class=nx>_Gdead</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>allgadd</span><span class=p>(</span><span class=nx>newg</span><span class=p>)</span> <span class=c1>// publishes with a g-&gt;status of Gdead so GC scanner doesn&#39;t look at uninitialized stack.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>newg</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>hi</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;newproc1: newg missing stack&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nf>readgstatus</span><span class=p>(</span><span class=nx>newg</span><span class=p>)</span> <span class=o>!=</span> <span class=nx>_Gdead</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;newproc1: new g is not Gdead&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>totalSize</span> <span class=o>:=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=mi>4</span><span class=o>*</span><span class=nx>goarch</span><span class=p>.</span><span class=nx>PtrSize</span> <span class=o>+</span> <span class=nx>sys</span><span class=p>.</span><span class=nx>MinFrameSize</span><span class=p>)</span> <span class=c1>// extra space in case of reads slightly beyond frame
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>totalSize</span> <span class=p>=</span> <span class=nf>alignUp</span><span class=p>(</span><span class=nx>totalSize</span><span class=p>,</span> <span class=nx>sys</span><span class=p>.</span><span class=nx>StackAlign</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>sp</span> <span class=o>:=</span> <span class=nx>newg</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>hi</span> <span class=o>-</span> <span class=nx>totalSize</span>
</span></span><span class=line><span class=cl>	<span class=nx>spArg</span> <span class=o>:=</span> <span class=nx>sp</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>usesLR</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// caller&#39;s LR
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=kt>uintptr</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>sp</span><span class=p>))</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>		<span class=nf>prepGoExitFrame</span><span class=p>(</span><span class=nx>sp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>spArg</span> <span class=o>+=</span> <span class=nx>sys</span><span class=p>.</span><span class=nx>MinFrameSize</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>memclrNoHeapPointers</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>newg</span><span class=p>.</span><span class=nx>sched</span><span class=p>),</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nx>newg</span><span class=p>.</span><span class=nx>sched</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 下面是各种初始化，可见 g.sched 是用于 g 本身信息
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>newg</span><span class=p>.</span><span class=nx>sched</span><span class=p>.</span><span class=nx>sp</span> <span class=p>=</span> <span class=nx>sp</span>
</span></span><span class=line><span class=cl>	<span class=nx>newg</span><span class=p>.</span><span class=nx>stktopsp</span> <span class=p>=</span> <span class=nx>sp</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 绑定了 goexit 函数，这里很重要，后边会调整 newg.sched.sp = goexit
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>newg</span><span class=p>.</span><span class=nx>sched</span><span class=p>.</span><span class=nx>pc</span> <span class=p>=</span> <span class=nx>abi</span><span class=p>.</span><span class=nf>FuncPCABI0</span><span class=p>(</span><span class=nx>goexit</span><span class=p>)</span> <span class=o>+</span> <span class=nx>sys</span><span class=p>.</span><span class=nx>PCQuantum</span> <span class=c1>// +PCQuantum so that previous instruction is in same function
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>newg</span><span class=p>.</span><span class=nx>sched</span><span class=p>.</span><span class=nx>g</span> <span class=p>=</span> <span class=nf>guintptr</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>newg</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 这里调整 pc 到 fn 的第一条指令，fn 被绑定到 sched.ctxt，sp = goexit
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>gostartcallfn</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>newg</span><span class=p>.</span><span class=nx>sched</span><span class=p>,</span> <span class=nx>fn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>newg</span><span class=p>.</span><span class=nx>parentGoid</span> <span class=p>=</span> <span class=nx>callergp</span><span class=p>.</span><span class=nx>goid</span>
</span></span><span class=line><span class=cl>	<span class=nx>newg</span><span class=p>.</span><span class=nx>gopc</span> <span class=p>=</span> <span class=nx>callerpc</span> <span class=c1>// 调用 newg 的 g 的 pc
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>newg</span><span class=p>.</span><span class=nx>ancestors</span> <span class=p>=</span> <span class=nf>saveAncestors</span><span class=p>(</span><span class=nx>callergp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>newg</span><span class=p>.</span><span class=nx>startpc</span> <span class=p>=</span> <span class=nx>fn</span><span class=p>.</span><span class=nx>fn</span> <span class=c1>// 实际执行的函数代码的位置
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nf>isSystemGoroutine</span><span class=p>(</span><span class=nx>newg</span><span class=p>,</span> <span class=kc>false</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>sched</span><span class=p>.</span><span class=nx>ngsys</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=c1>// 调度器系统 g +1
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Only user goroutines inherit pprof labels.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>curg</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>newg</span><span class=p>.</span><span class=nx>labels</span> <span class=p>=</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>curg</span><span class=p>.</span><span class=nx>labels</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>goroutineProfile</span><span class=p>.</span><span class=nx>active</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// A concurrent goroutine profile is running. It should include
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// exactly the set of goroutines that were alive when the goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// profiler first stopped the world. That does not include newg, so
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// mark it as not needing a profile before transitioning it from
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// _Gdead.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>newg</span><span class=p>.</span><span class=nx>goroutineProfiled</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=nx>goroutineProfileSatisfied</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>newg</span><span class=p>.</span><span class=nx>trackingSeq</span> <span class=p>=</span> <span class=nb>uint8</span><span class=p>(</span><span class=nf>fastrand</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>newg</span><span class=p>.</span><span class=nx>trackingSeq</span><span class=o>%</span><span class=nx>gTrackingPeriod</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>newg</span><span class=p>.</span><span class=nx>tracking</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 切换 newg 状态到可运行
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>casgstatus</span><span class=p>(</span><span class=nx>newg</span><span class=p>,</span> <span class=nx>_Gdead</span><span class=p>,</span> <span class=nx>_Grunnable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// newg 的栈加入 gc 的可扫描栈中，方便垃圾回收
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>gcController</span><span class=p>.</span><span class=nf>addScannableStack</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span> <span class=nb>int64</span><span class=p>(</span><span class=nx>newg</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>hi</span><span class=o>-</span><span class=nx>newg</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>lo</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// goid 计数器，起得名字不接地气
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>pp</span><span class=p>.</span><span class=nx>goidcache</span> <span class=o>==</span> <span class=nx>pp</span><span class=p>.</span><span class=nx>goidcacheend</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Sched.goidgen is the last allocated id,
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// At startup sched.goidgen=0, so main goroutine receives goid=1.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>pp</span><span class=p>.</span><span class=nx>goidcache</span> <span class=p>=</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>goidgen</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=nx>_GoidCacheBatch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>pp</span><span class=p>.</span><span class=nx>goidcache</span> <span class=o>-=</span> <span class=nx>_GoidCacheBatch</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=nx>pp</span><span class=p>.</span><span class=nx>goidcacheend</span> <span class=p>=</span> <span class=nx>pp</span><span class=p>.</span><span class=nx>goidcache</span> <span class=o>+</span> <span class=nx>_GoidCacheBatch</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>newg</span><span class=p>.</span><span class=nx>goid</span> <span class=p>=</span> <span class=nx>pp</span><span class=p>.</span><span class=nx>goidcache</span>
</span></span><span class=line><span class=cl>	<span class=nx>pp</span><span class=p>.</span><span class=nx>goidcache</span><span class=o>++</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>raceenabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>newg</span><span class=p>.</span><span class=nx>racectx</span> <span class=p>=</span> <span class=nf>racegostart</span><span class=p>(</span><span class=nx>callerpc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>newg</span><span class=p>.</span><span class=nx>raceignore</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>newg</span><span class=p>.</span><span class=nx>labels</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// See note in proflabel.go on labelSync&#39;s role in synchronizing
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// with the reads in the signal handler.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nf>racereleasemergeg</span><span class=p>(</span><span class=nx>newg</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>labelSync</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nf>traceEnabled</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>traceGoCreate</span><span class=p>(</span><span class=nx>newg</span><span class=p>,</span> <span class=nx>newg</span><span class=p>.</span><span class=nx>startpc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>releasem</span><span class=p>(</span><span class=nx>mp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>newg</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// [runtime/asm_amd64.s]
</span></span></span><span class=line><span class=cl><span class=c1>// func systemstack(fn func())
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>TEXT</span> <span class=nx>runtime</span><span class=err>·</span><span class=nf>systemstack</span><span class=p>(</span><span class=nx>SB</span><span class=p>),</span> <span class=nx>NOSPLIT</span><span class=p>,</span> <span class=err>$</span><span class=mi>0</span><span class=o>-</span><span class=mi>8</span>
</span></span><span class=line><span class=cl>	<span class=nx>MOVQ</span>	<span class=nx>fn</span><span class=o>+</span><span class=mi>0</span><span class=p>(</span><span class=nx>FP</span><span class=p>),</span> <span class=nx>DI</span>	<span class=c1>// DI = fn      // DI = main
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>get_tls</span><span class=p>(</span><span class=nx>CX</span><span class=p>)</span>                             <span class=c1>// CX = TLS
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nf>g</span><span class=p>(</span><span class=nx>CX</span><span class=p>),</span> <span class=nx>AX</span>	<span class=c1>// AX = g           // 启动阶段 AX = g0
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nf>g_m</span><span class=p>(</span><span class=nx>AX</span><span class=p>),</span> <span class=nx>BX</span>	<span class=c1>// BX = m           // 启动阶段 BX = g0.m0
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>CMPQ</span>	<span class=nx>AX</span><span class=p>,</span> <span class=nf>m_gsignal</span><span class=p>(</span><span class=nx>BX</span><span class=p>)</span>               <span class=c1>// 启动阶段 m0.gsignal 是新创建的，对应执行代码都没，不可能相等
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>JEQ</span>	<span class=nx>noswitch</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>MOVQ</span>	<span class=nf>m_g0</span><span class=p>(</span><span class=nx>BX</span><span class=p>),</span> <span class=nx>DX</span>	<span class=c1>// DX = g0      // DX = m.g0，启动阶段 DX = m0.g0
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>CMPQ</span>	<span class=nx>AX</span><span class=p>,</span> <span class=nx>DX</span>                          <span class=c1>// 启动阶段，相等
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>JEQ</span>	<span class=nx>noswitch</span>                            <span class=c1>// 启动阶段跳转到 noswitch
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>CMPQ</span>	<span class=nx>AX</span><span class=p>,</span> <span class=nf>m_curg</span><span class=p>(</span><span class=nx>BX</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>JNE</span>	<span class=nx>bad</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Switch stacks.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// The original frame pointer is stored in BP,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// which is useful for stack unwinding.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Save our state in g-&gt;sched. Pretend to
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// be systemstack_switch if the G stack is scanned.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>CALL</span>	<span class=nx>gosave_systemstack_switch</span><span class=p>&lt;&gt;(</span><span class=nx>SB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// switch to g0
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nx>DX</span><span class=p>,</span> <span class=nf>g</span><span class=p>(</span><span class=nx>CX</span><span class=p>)</span>                       <span class=c1>// TLS.g = m.g0
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nx>DX</span><span class=p>,</span> <span class=nx>R14</span> <span class=c1>// set the g register   // R14 = TLS.g = m.g0
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>MOVQ</span>	<span class=p>(</span><span class=nx>g_sched</span><span class=o>+</span><span class=nx>gobuf_sp</span><span class=p>)(</span><span class=nx>DX</span><span class=p>),</span> <span class=nx>SP</span>      <span class=c1>// SP = m.g0.sched.gobuf.sp 栈指针换到 g0 的栈上
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// call target function                 // 开始执行 fn 函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nx>DI</span><span class=p>,</span> <span class=nx>DX</span>
</span></span><span class=line><span class=cl>	<span class=nx>MOVQ</span>	<span class=mi>0</span><span class=p>(</span><span class=nx>DI</span><span class=p>),</span> <span class=nx>DI</span>
</span></span><span class=line><span class=cl>	<span class=nx>CALL</span>	<span class=nx>DI</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// switch back to g                     // 执行结束，回到 g 的栈
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>get_tls</span><span class=p>(</span><span class=nx>CX</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>MOVQ</span>	<span class=nf>g</span><span class=p>(</span><span class=nx>CX</span><span class=p>),</span> <span class=nx>AX</span>
</span></span><span class=line><span class=cl>	<span class=nx>MOVQ</span>	<span class=nf>g_m</span><span class=p>(</span><span class=nx>AX</span><span class=p>),</span> <span class=nx>BX</span>
</span></span><span class=line><span class=cl>	<span class=nx>MOVQ</span>	<span class=nf>m_curg</span><span class=p>(</span><span class=nx>BX</span><span class=p>),</span> <span class=nx>AX</span>
</span></span><span class=line><span class=cl>	<span class=nx>MOVQ</span>	<span class=nx>AX</span><span class=p>,</span> <span class=nf>g</span><span class=p>(</span><span class=nx>CX</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>MOVQ</span>	<span class=p>(</span><span class=nx>g_sched</span><span class=o>+</span><span class=nx>gobuf_sp</span><span class=p>)(</span><span class=nx>AX</span><span class=p>),</span> <span class=nx>SP</span>
</span></span><span class=line><span class=cl>	<span class=nf>MOVQ</span>	<span class=p>(</span><span class=nx>g_sched</span><span class=o>+</span><span class=nx>gobuf_bp</span><span class=p>)(</span><span class=nx>AX</span><span class=p>),</span> <span class=nx>BP</span>
</span></span><span class=line><span class=cl>	<span class=nx>MOVQ</span>	<span class=err>$</span><span class=mi>0</span><span class=p>,</span> <span class=p>(</span><span class=nx>g_sched</span><span class=o>+</span><span class=nx>gobuf_sp</span><span class=p>)(</span><span class=nx>AX</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>MOVQ</span>	<span class=err>$</span><span class=mi>0</span><span class=p>,</span> <span class=p>(</span><span class=nx>g_sched</span><span class=o>+</span><span class=nx>gobuf_bp</span><span class=p>)(</span><span class=nx>AX</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>RET</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>noswitch</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=c1>// already on m stack; tail call the function
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Using a tail call here cleans up tracebacks since we won&#39;t stop
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// at an intermediate systemstack.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nx>DI</span><span class=p>,</span> <span class=nx>DX</span>                  <span class=c1>// DX = fn，启动阶段 DX = main
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=mi>0</span><span class=p>(</span><span class=nx>DI</span><span class=p>),</span> <span class=nx>DI</span>
</span></span><span class=line><span class=cl>	<span class=c1>// The function epilogue is not called on a tail call.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Pop BP from the stack to simulate it.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>POPQ</span>	<span class=nx>BP</span>
</span></span><span class=line><span class=cl>	<span class=nx>JMP</span>	<span class=nx>DI</span>                          <span class=c1>// 执行 fn
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>bad</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Bad: g is not gsignal, not g0, not curg. What is it?
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=err>$</span><span class=nx>runtime</span><span class=err>·</span><span class=nf>badsystemstack</span><span class=p>(</span><span class=nx>SB</span><span class=p>),</span> <span class=nx>AX</span>
</span></span><span class=line><span class=cl>	<span class=nx>CALL</span>	<span class=nx>AX</span>
</span></span><span class=line><span class=cl>	<span class=nx>INT</span>	<span class=err>$</span><span class=mi>3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// [runtime/stack.go]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>gostartcallfn</span><span class=p>(</span><span class=nx>gobuf</span> <span class=o>*</span><span class=nx>gobuf</span><span class=p>,</span> <span class=nx>fv</span> <span class=o>*</span><span class=nx>funcval</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>fn</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>fv</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fn</span> <span class=p>=</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>fv</span><span class=p>.</span><span class=nx>fn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fn</span> <span class=p>=</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>abi</span><span class=p>.</span><span class=nf>FuncPCABIInternal</span><span class=p>(</span><span class=nx>nilfunc</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>gostartcall</span><span class=p>(</span><span class=nx>gobuf</span><span class=p>,</span> <span class=nx>fn</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>fv</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// [runtime/sys_x86.go]
</span></span></span><span class=line><span class=cl><span class=c1>// adjust Gobuf as if it executed a call to fn with context ctxt
</span></span></span><span class=line><span class=cl><span class=c1>// and then stopped before the first instruction in fn.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>gostartcall</span><span class=p>(</span><span class=nx>buf</span> <span class=o>*</span><span class=nx>gobuf</span><span class=p>,</span> <span class=nx>fn</span><span class=p>,</span> <span class=nx>ctxt</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>sp</span> <span class=o>:=</span> <span class=nx>buf</span><span class=p>.</span><span class=nx>sp</span>
</span></span><span class=line><span class=cl>	<span class=nx>sp</span> <span class=o>-=</span> <span class=nx>goarch</span><span class=p>.</span><span class=nx>PtrSize</span>
</span></span><span class=line><span class=cl>	<span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=kt>uintptr</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>sp</span><span class=p>))</span> <span class=p>=</span> <span class=nx>buf</span><span class=p>.</span><span class=nx>pc</span> <span class=c1>// sp = buf.pc = goexit
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>buf</span><span class=p>.</span><span class=nx>sp</span> <span class=p>=</span> <span class=nx>sp</span>
</span></span><span class=line><span class=cl>	<span class=nx>buf</span><span class=p>.</span><span class=nx>pc</span> <span class=p>=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>fn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>buf</span><span class=p>.</span><span class=nx>ctxt</span> <span class=p>=</span> <span class=nx>ctxt</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// [runtime/proc.go]
</span></span></span><span class=line><span class=cl><span class=c1>// The main goroutine.
</span></span></span><span class=line><span class=cl><span class=c1>// 这是启动时 newproc 中的 fn 参数，后边解释
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>......</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>newproc</code> 除了创建协程加入调度队列外，不可忽视的细节是创建的协程的 <code>sp</code> 上放了 <code>goexit</code> 的地址，这对调度循环很重要，如果没有这个细节，协程执行完退出后不能开启下次调度，具体细节会在下面说明</p><h2 id=mstart><code>mstart</code></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// [runtime/proc.go]
</span></span></span><span class=line><span class=cl><span class=c1>// mstart0 is the Go entry-point for new Ms.
</span></span></span><span class=line><span class=cl><span class=c1>// This must not split the stack because we may not even have stack
</span></span></span><span class=line><span class=cl><span class=c1>// bounds set up yet.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// May run during STW (because it doesn&#39;t have a P yet), so write
</span></span></span><span class=line><span class=cl><span class=c1>// barriers are not allowed.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//go:nosplit
</span></span></span><span class=line><span class=cl><span class=c1>//go:nowritebarrierrec
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>mstart0</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>osStack</span> <span class=o>:=</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>lo</span> <span class=o>==</span> <span class=mi>0</span> <span class=c1>// 现在的 g 还是 g0，g0.stack.lo != 0
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>osStack</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Initialize stack bounds from system stack.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// Cgo may have left stack size in stack.hi.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// minit may update the stack bounds.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// Note: these bounds may not be very accurate.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// We set hi to &amp;size, but there are things above
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// it. The 1024 is supposed to compensate this,
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// but is somewhat arbitrary.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>size</span> <span class=o>:=</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>hi</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>size</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>size</span> <span class=p>=</span> <span class=mi>16384</span> <span class=o>*</span> <span class=nx>sys</span><span class=p>.</span><span class=nx>StackGuardMultiplier</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>gp</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>hi</span> <span class=p>=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nf>noescape</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>size</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>		<span class=nx>gp</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>lo</span> <span class=p>=</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>hi</span> <span class=o>-</span> <span class=nx>size</span> <span class=o>+</span> <span class=mi>1024</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Initialize stack guard so that we can start calling regular
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Go code.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>gp</span><span class=p>.</span><span class=nx>stackguard0</span> <span class=p>=</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>lo</span> <span class=o>+</span> <span class=nx>stackGuard</span>
</span></span><span class=line><span class=cl>	<span class=c1>// This is the g0, so we can also call go:systemstack
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// functions, which check stackguard1.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>gp</span><span class=p>.</span><span class=nx>stackguard1</span> <span class=p>=</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>stackguard0</span>
</span></span><span class=line><span class=cl>	<span class=nf>mstart1</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Exit this thread.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nf>mStackIsSystemAllocated</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// the stack, but put it in gp.stack before mstart,
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// so the logic above hasn&#39;t set osStack yet.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>osStack</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>mexit</span><span class=p>(</span><span class=nx>osStack</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// The go:noinline is to guarantee the getcallerpc/getcallersp below are safe,
</span></span></span><span class=line><span class=cl><span class=c1>// so that we can set up g0.sched to return to the call of mstart1 above.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//go:noinline
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>mstart1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>gp</span> <span class=o>!=</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>g0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;bad runtime·mstart&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Set up m.g0.sched as a label returning to just
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// after the mstart1 call in mstart0 above, for use by goexit0 and mcall.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// We&#39;re never coming back to mstart1 after we call schedule,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// so other calls can reuse the current frame.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// And goexit0 does a gogo that needs to return from mstart1
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// and let mstart0 exit the thread.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>gp</span><span class=p>.</span><span class=nx>sched</span><span class=p>.</span><span class=nx>g</span> <span class=p>=</span> <span class=nf>guintptr</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>gp</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>sched</span><span class=p>.</span><span class=nx>pc</span> <span class=p>=</span> <span class=nf>getcallerpc</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>sched</span><span class=p>.</span><span class=nx>sp</span> <span class=p>=</span> <span class=nf>getcallersp</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>asminit</span><span class=p>()</span> <span class=c1>// [runtime/asm_amd64.s] 空函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>minit</span><span class=p>()</span> <span class=c1>// 处理 m 上 gSignal 协程相关
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// Install signal handlers; after minit so that minit can
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// prepare the thread to be able to handle the signals.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>m</span> <span class=o>==</span> <span class=o>&amp;</span><span class=nx>m0</span> <span class=p>{</span> <span class=c1>// g0.m == m0
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>mstartm0</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>fn</span> <span class=o>:=</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>mstartfn</span><span class=p>;</span> <span class=nx>fn</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span> <span class=c1>// m0 上 mstartfn = nil
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>fn</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>m</span> <span class=o>!=</span> <span class=o>&amp;</span><span class=nx>m0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>acquirep</span><span class=p>(</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>nextp</span><span class=p>.</span><span class=nf>ptr</span><span class=p>())</span>
</span></span><span class=line><span class=cl>		<span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>nextp</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>schedule</span><span class=p>()</span> <span class=c1>// 真正开始调度循环
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// mstartm0 implements part of mstart1 that only runs on the m0.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Write barriers are allowed here because we know the GC can&#39;t be
</span></span></span><span class=line><span class=cl><span class=c1>// running yet, so they&#39;ll be no-ops.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//go:yeswritebarrierrec
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>mstartm0</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Create an extra M for callbacks on threads not created by Go.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// An extra M is also needed on Windows for callbacks created by
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// syscall.NewCallback. See issue #6751 for details.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=nx>iscgo</span> <span class=o>||</span> <span class=nx>GOOS</span> <span class=o>==</span> <span class=s>&#34;windows&#34;</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>cgoHasExtraM</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>cgoHasExtraM</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=nf>newextram</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>initsig</span><span class=p>(</span><span class=kc>false</span><span class=p>)</span> <span class=c1>// 注册信号处理函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>至此，创建了新的 <code>g</code>，并加入到 <code>m0.p.runnext</code> 中了，新 <code>g</code> 中函数是 <code>proc.main</code>，还不是用户空间的代码；期间还对系统全局的 <code>allp</code> <code>stackpoll</code> 等进行了初始化，但是 gc 还没有启动，调度循环也没有启动，接下来要运行 <code>schedule</code> 进入调度循环。</p><h1 id=m0-上开启第一次调度>m0 上开启第一次调度</h1><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span><span class=lnt>89
</span><span class=lnt>90
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// One round of scheduler: find a runnable goroutine and execute it.
</span></span></span><span class=line><span class=cl><span class=c1>// Never returns.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>schedule</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>mp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>().</span><span class=nx>m</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// m 被锁定，不应该执行调度
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>locks</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;schedule: holding locks&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// m 上有绑定的 g，将 m 休眠到直到 g 可以运行
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>lockedg</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>stoplockedm</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nf>execute</span><span class=p>(</span><span class=nx>mp</span><span class=p>.</span><span class=nx>lockedg</span><span class=p>.</span><span class=nf>ptr</span><span class=p>(),</span> <span class=kc>false</span><span class=p>)</span> <span class=c1>// Never returns.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// We should not schedule away from a g that is executing a cgo call,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// since the cgo call is using the m&#39;s g0 stack.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>incgo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;schedule: in cgo&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>top</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=nx>pp</span> <span class=o>:=</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>pp</span><span class=p>.</span><span class=nx>preempt</span> <span class=p>=</span> <span class=kc>false</span>  <span class=c1>// 调度开始，当前正在运行的 P 不能被抢占
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// Safety check: if we are spinning, the run queue should be empty.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Check this before calling checkTimers, as that might call
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// goready to put a ready goroutine on the local run queue.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>spinning</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runnext</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>pp</span><span class=p>.</span><span class=nx>runqhead</span> <span class=o>!=</span> <span class=nx>pp</span><span class=p>.</span><span class=nx>runqtail</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;schedule: spinning with local work&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 得到 g ，剩余时间片，和是否进行 gcBlacken 的后台工作
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>gp</span><span class=p>,</span> <span class=nx>inheritTime</span><span class=p>,</span> <span class=nx>tryWakeP</span> <span class=o>:=</span> <span class=nf>findRunnable</span><span class=p>()</span> <span class=c1>// blocks until work is available
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>debug</span><span class=p>.</span><span class=nx>dontfreezetheworld</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>freezing</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// See comment in freezetheworld. We don&#39;t want to perturb
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// scheduler state, so we didn&#39;t gcstopm in findRunnable, but
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// also don&#39;t want to allow new goroutines to run.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// Deadlock here rather than in the findRunnable loop so if
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// findRunnable is stuck in a loop we don&#39;t perturb that
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// either.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>deadlock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>deadlock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// This thread is going to run a goroutine and is not spinning anymore,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// so if it was marked as spinning we need to reset it now and potentially
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// start a new spinning M.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 取消自旋的 m 的自旋状态
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>spinning</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>resetspinning</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// gc 前台执行 STW，停止调度当前协程
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>disable</span><span class=p>.</span><span class=nx>user</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nf>schedEnabled</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Scheduling of this goroutine is disabled. Put it on
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// the list of pending runnable goroutines for when we
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// re-enable user scheduling and look again.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nf>schedEnabled</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// Something re-enabled scheduling while we
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// were acquiring the lock.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>sched</span><span class=p>.</span><span class=nx>disable</span><span class=p>.</span><span class=nx>runnable</span><span class=p>.</span><span class=nf>pushBack</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>sched</span><span class=p>.</span><span class=nx>disable</span><span class=p>.</span><span class=nx>n</span><span class=o>++</span>
</span></span><span class=line><span class=cl>			<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>goto</span> <span class=nx>top</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// If about to schedule a not-normal goroutine (a GCworker or tracereader),
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// wake a P if there is one.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 执行 gc 后台标记和 trace 的协程，只有闲时才有
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>tryWakeP</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>wakep</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 调度到的 g 上绑定了 m，无私奉献了自己的 p 给 g
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>lockedm</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Hands off own p to the locked m,
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// then blocks waiting for a new p.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>startlockedm</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>goto</span> <span class=nx>top</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>execute</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>inheritTime</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>确定当前 <code>m</code> 是否有绑定 <code>g</code>，绑定 <code>g</code> 一般是为了进行系统调度需要阻塞，如果这个阻塞的 <code>g</code> 还放在 <code>p</code> 的队列上，会影响效率。如果有绑定，则让出 <code>p</code> 并休眠 <code>m</code> 等待 <code>g</code> 满足条件执行</li><li><code>gc</code> 在 <code>STW</code> 时停止所有调度</li><li>寻找可以运行的 <code>g</code>，不一定有，没有则说明系统清闲，使用 <code>tryWake</code> 提醒可以调度 <code>gc</code> 等运行时工作，这也是 <code>gc</code> 的并发标记来源</li><li>找到的 <code>g</code> 可能有绑定的 <code>m</code>，则贡献自己的 <code>p</code> 给它们，重新调度</li><li>运行找到的 <code>g</code></li></ul><h2 id=g-的创建><code>g</code> 的创建</h2><p>进入运行时前的准备阶段，我们已经分析了第一个 <code>g</code>，也就是承载 <code>runtime/proc.main</code> 函数的 <code>g</code> 怎么被创建的，但是一般我们创建 <code>g</code> 是使用 <code>go</code> 关键字，所以这里需要搞清楚 <code>go</code> 关键字究竟做了什么，内部是不是一样调用 <code>newproc</code> 函数，这里还是用 <code>gdb</code> 看下 <code>go</code> 关键字会执行什么指令</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>println</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>直接在 gdb 中 <code>start</code> 进入 <code>main</code> 函数，再 <code>disassemble</code> 查看汇编代码，或者继续步入调试到 <code>go</code> 关键字行</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(gdb) start
</span></span><span class=line><span class=cl>Thread 1 &#34;gmp&#34; hit Temporary breakpoint 1, main.main () at ~~~~
</span></span><span class=line><span class=cl>3       func main() {
</span></span><span class=line><span class=cl>(gdb) disassemble
</span></span><span class=line><span class=cl>Dump of assembler code for function main.main:
</span></span><span class=line><span class=cl>   0x00000000004576c0 &lt;+0&gt;:     cmp    0x10(%r14),%rsp
</span></span><span class=line><span class=cl>   0x00000000004576c4 &lt;+4&gt;:     jbe    0x4576e1 &lt;main.main+33&gt;
</span></span><span class=line><span class=cl>   0x00000000004576c6 &lt;+6&gt;:     push   %rbp
</span></span><span class=line><span class=cl>   0x00000000004576c7 &lt;+7&gt;:     mov    %rsp,%rbp
</span></span><span class=line><span class=cl>=&gt; 0x00000000004576ca &lt;+10&gt;:    sub    $0x8,%rsp
</span></span><span class=line><span class=cl>   0x00000000004576ce &lt;+14&gt;:    lea    0x14963(%rip),%rax        # 0x46c038
</span></span><span class=line><span class=cl>   0x00000000004576d5 &lt;+21&gt;:    call   0x437480 &lt;runtime.newproc&gt;
</span></span><span class=line><span class=cl>   0x00000000004576da &lt;+26&gt;:    add    $0x8,%rsp
</span></span><span class=line><span class=cl>   0x00000000004576de &lt;+30&gt;:    pop    %rbp
</span></span><span class=line><span class=cl>   0x00000000004576df &lt;+31&gt;:    nop
</span></span><span class=line><span class=cl>   0x00000000004576e0 &lt;+32&gt;:    ret
</span></span><span class=line><span class=cl>   0x00000000004576e1 &lt;+33&gt;:    call   0x454620 &lt;runtime.morestack_noctxt&gt;
</span></span><span class=line><span class=cl>   0x00000000004576e6 &lt;+38&gt;:    jmp    0x4576c0 &lt;main.main&gt;
</span></span><span class=line><span class=cl>(gdb) s
</span></span><span class=line><span class=cl>4               go func() {
</span></span><span class=line><span class=cl>(gdb) s
</span></span><span class=line><span class=cl>runtime.newproc (fn=0x46c038) at /usr/lib/go/src/runtime/proc.go:4477
</span></span><span class=line><span class=cl>4477    func newproc(fn *funcval) {
</span></span></code></pre></td></tr></table></div></div><p>可以看出 <code>go</code> 关键字最终也会运行 <code>runtime.newproc</code>，这个函数上面有分析，总结下就是</p><ul><li>切换到 <code>m.g0</code> 上，执行 <code>runtime.newproc1</code> 为新的 <code>g</code> 初始化，绑定用户函数的第一个指令地址到 <code>g.sched.pc</code> 上，把 <code>goexit</code> 函数的地址放到栈顶，这是最后 <code>g</code> 结束时的出口，也是能保证下次调度能正常开始</li><li>获取 <code>p</code>，将新的 <code>g</code> 放到 <code>p</code> 中，<code>wakep</code> 尝试启动新的 <code>mp</code> 去运行，这也就开始其他 <code>m</code> 的创建</li></ul><h2 id=怎么找到可执行的-g>怎么找到可执行的 <code>g</code></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span><span class=lnt>195
</span><span class=lnt>196
</span><span class=lnt>197
</span><span class=lnt>198
</span><span class=lnt>199
</span><span class=lnt>200
</span><span class=lnt>201
</span><span class=lnt>202
</span><span class=lnt>203
</span><span class=lnt>204
</span><span class=lnt>205
</span><span class=lnt>206
</span><span class=lnt>207
</span><span class=lnt>208
</span><span class=lnt>209
</span><span class=lnt>210
</span><span class=lnt>211
</span><span class=lnt>212
</span><span class=lnt>213
</span><span class=lnt>214
</span><span class=lnt>215
</span><span class=lnt>216
</span><span class=lnt>217
</span><span class=lnt>218
</span><span class=lnt>219
</span><span class=lnt>220
</span><span class=lnt>221
</span><span class=lnt>222
</span><span class=lnt>223
</span><span class=lnt>224
</span><span class=lnt>225
</span><span class=lnt>226
</span><span class=lnt>227
</span><span class=lnt>228
</span><span class=lnt>229
</span><span class=lnt>230
</span><span class=lnt>231
</span><span class=lnt>232
</span><span class=lnt>233
</span><span class=lnt>234
</span><span class=lnt>235
</span><span class=lnt>236
</span><span class=lnt>237
</span><span class=lnt>238
</span><span class=lnt>239
</span><span class=lnt>240
</span><span class=lnt>241
</span><span class=lnt>242
</span><span class=lnt>243
</span><span class=lnt>244
</span><span class=lnt>245
</span><span class=lnt>246
</span><span class=lnt>247
</span><span class=lnt>248
</span><span class=lnt>249
</span><span class=lnt>250
</span><span class=lnt>251
</span><span class=lnt>252
</span><span class=lnt>253
</span><span class=lnt>254
</span><span class=lnt>255
</span><span class=lnt>256
</span><span class=lnt>257
</span><span class=lnt>258
</span><span class=lnt>259
</span><span class=lnt>260
</span><span class=lnt>261
</span><span class=lnt>262
</span><span class=lnt>263
</span><span class=lnt>264
</span><span class=lnt>265
</span><span class=lnt>266
</span><span class=lnt>267
</span><span class=lnt>268
</span><span class=lnt>269
</span><span class=lnt>270
</span><span class=lnt>271
</span><span class=lnt>272
</span><span class=lnt>273
</span><span class=lnt>274
</span><span class=lnt>275
</span><span class=lnt>276
</span><span class=lnt>277
</span><span class=lnt>278
</span><span class=lnt>279
</span><span class=lnt>280
</span><span class=lnt>281
</span><span class=lnt>282
</span><span class=lnt>283
</span><span class=lnt>284
</span><span class=lnt>285
</span><span class=lnt>286
</span><span class=lnt>287
</span><span class=lnt>288
</span><span class=lnt>289
</span><span class=lnt>290
</span><span class=lnt>291
</span><span class=lnt>292
</span><span class=lnt>293
</span><span class=lnt>294
</span><span class=lnt>295
</span><span class=lnt>296
</span><span class=lnt>297
</span><span class=lnt>298
</span><span class=lnt>299
</span><span class=lnt>300
</span><span class=lnt>301
</span><span class=lnt>302
</span><span class=lnt>303
</span><span class=lnt>304
</span><span class=lnt>305
</span><span class=lnt>306
</span><span class=lnt>307
</span><span class=lnt>308
</span><span class=lnt>309
</span><span class=lnt>310
</span><span class=lnt>311
</span><span class=lnt>312
</span><span class=lnt>313
</span><span class=lnt>314
</span><span class=lnt>315
</span><span class=lnt>316
</span><span class=lnt>317
</span><span class=lnt>318
</span><span class=lnt>319
</span><span class=lnt>320
</span><span class=lnt>321
</span><span class=lnt>322
</span><span class=lnt>323
</span><span class=lnt>324
</span><span class=lnt>325
</span><span class=lnt>326
</span><span class=lnt>327
</span><span class=lnt>328
</span><span class=lnt>329
</span><span class=lnt>330
</span><span class=lnt>331
</span><span class=lnt>332
</span><span class=lnt>333
</span><span class=lnt>334
</span><span class=lnt>335
</span><span class=lnt>336
</span><span class=lnt>337
</span><span class=lnt>338
</span><span class=lnt>339
</span><span class=lnt>340
</span><span class=lnt>341
</span><span class=lnt>342
</span><span class=lnt>343
</span><span class=lnt>344
</span><span class=lnt>345
</span><span class=lnt>346
</span><span class=lnt>347
</span><span class=lnt>348
</span><span class=lnt>349
</span><span class=lnt>350
</span><span class=lnt>351
</span><span class=lnt>352
</span><span class=lnt>353
</span><span class=lnt>354
</span><span class=lnt>355
</span><span class=lnt>356
</span><span class=lnt>357
</span><span class=lnt>358
</span><span class=lnt>359
</span><span class=lnt>360
</span><span class=lnt>361
</span><span class=lnt>362
</span><span class=lnt>363
</span><span class=lnt>364
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Finds a runnable goroutine to execute.
</span></span></span><span class=line><span class=cl><span class=c1>// Tries to steal from other P&#39;s, get g from local or global queue, poll network.
</span></span></span><span class=line><span class=cl><span class=c1>// tryWakeP indicates that the returned goroutine is not normal (GC worker, trace
</span></span></span><span class=line><span class=cl><span class=c1>// reader) so the caller should try to wake a P.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>findRunnable</span><span class=p>()</span> <span class=p>(</span><span class=nx>gp</span> <span class=o>*</span><span class=nx>g</span><span class=p>,</span> <span class=nx>inheritTime</span><span class=p>,</span> <span class=nx>tryWakeP</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>mp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>().</span><span class=nx>m</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// The conditions here and in handoffp must agree: if
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// findrunnable would return a G to run, handoffp must start
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// an M.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>top</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=nx>pp</span> <span class=o>:=</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>gcwaiting</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// STW 阻塞
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>gcstopm</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>goto</span> <span class=nx>top</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>pp</span><span class=p>.</span><span class=nx>runSafePointFn</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>runSafePointFn</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// now and pollUntil are saved for work stealing later,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// which may steal timers. It&#39;s important that between now
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// and then, nothing blocks, so these numbers remain mostly
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// relevant.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>now</span><span class=p>,</span> <span class=nx>pollUntil</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nf>checkTimers</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Try to schedule the trace reader.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nf>traceEnabled</span><span class=p>()</span> <span class=o>||</span> <span class=nf>traceShuttingDown</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>gp</span> <span class=o>:=</span> <span class=nf>traceReader</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>gp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>_Gwaiting</span><span class=p>,</span> <span class=nx>_Grunnable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nf>traceGoUnpark</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>gp</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Try to schedule a GC worker.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 尝试从 gc worker 获取， gc worker 是单独用于 gc 后台标记的协程，外部的 tryWake 就是可以创建这种协程
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>gcBlackenEnabled</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>gp</span><span class=p>,</span> <span class=nx>tnow</span> <span class=o>:=</span> <span class=nx>gcController</span><span class=p>.</span><span class=nf>findRunnableGCWorker</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span> <span class=nx>now</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>gp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>gp</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>now</span> <span class=p>=</span> <span class=nx>tnow</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Check the global runnable queue once in a while to ensure fairness.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Otherwise two goroutines can completely occupy the local runqueue
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// by constantly respawning each other.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 每 61 次调度尝试从全局调度器中获取
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>pp</span><span class=p>.</span><span class=nx>schedtick</span><span class=o>%</span><span class=mi>61</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>runqsize</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>gp</span> <span class=o>:=</span> <span class=nf>globrunqget</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>gp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>gp</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Wake up the finalizer G.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>fingStatus</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span><span class=o>&amp;</span><span class=p>(</span><span class=nx>fingWait</span><span class=p>|</span><span class=nx>fingWake</span><span class=p>)</span> <span class=o>==</span> <span class=nx>fingWait</span><span class=p>|</span><span class=nx>fingWake</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>gp</span> <span class=o>:=</span> <span class=nf>wakefing</span><span class=p>();</span> <span class=nx>gp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>ready</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=o>*</span><span class=nx>cgo_yield</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>asmcgocall</span><span class=p>(</span><span class=o>*</span><span class=nx>cgo_yield</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// local runq
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 从本地队列获取
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>gp</span><span class=p>,</span> <span class=nx>inheritTime</span> <span class=o>:=</span> <span class=nf>runqget</span><span class=p>(</span><span class=nx>pp</span><span class=p>);</span> <span class=nx>gp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>gp</span><span class=p>,</span> <span class=nx>inheritTime</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// global runq
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 全局队列获取
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>runqsize</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>gp</span> <span class=o>:=</span> <span class=nf>globrunqget</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>gp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>gp</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Poll network.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// This netpoll is only an optimization before we resort to stealing.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// We can safely skip it if there are no waiters or a thread is blocked
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// in netpoll already. If there is any kind of logical race with that
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// blocked thread (e.g. it has already returned from netpoll, but does
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// not set lastpoll yet), this thread will do blocking netpoll below
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// anyway.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 尝试从不为空的 netpoll 获取
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nf>netpollinited</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=nx>netpollWaiters</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>lastpoll</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>list</span> <span class=o>:=</span> <span class=nf>netpoll</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=p>!</span><span class=nx>list</span><span class=p>.</span><span class=nf>empty</span><span class=p>()</span> <span class=p>{</span> <span class=c1>// non-blocking
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>gp</span> <span class=o>:=</span> <span class=nx>list</span><span class=p>.</span><span class=nf>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=nf>injectglist</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>_Gwaiting</span><span class=p>,</span> <span class=nx>_Grunnable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nf>traceEnabled</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nf>traceGoUnpark</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>gp</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Spinning Ms: steal work from other Ps.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Limit the number of spinning Ms to half the number of busy Ps.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// This is necessary to prevent excessive CPU consumption when
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// GOMAXPROCS&gt;&gt;1 but the program parallelism is low.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 如果当前 m 在自旋或者此时自旋的 m 数小于忙碌的 p 的一半，那么为当前 m 窃取工作
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>spinning</span> <span class=o>||</span> <span class=mi>2</span><span class=o>*</span><span class=nx>sched</span><span class=p>.</span><span class=nx>nmspinning</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span> <span class=p>&lt;</span> <span class=nx>gomaxprocs</span><span class=o>-</span><span class=nx>sched</span><span class=p>.</span><span class=nx>npidle</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>!</span><span class=nx>mp</span><span class=p>.</span><span class=nx>spinning</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>mp</span><span class=p>.</span><span class=nf>becomeSpinning</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 尝试 4 次随机 p 窃取
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>gp</span><span class=p>,</span> <span class=nx>inheritTime</span><span class=p>,</span> <span class=nx>tnow</span><span class=p>,</span> <span class=nx>w</span><span class=p>,</span> <span class=nx>newWork</span> <span class=o>:=</span> <span class=nf>stealWork</span><span class=p>(</span><span class=nx>now</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>gp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// Successfully stole.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>return</span> <span class=nx>gp</span><span class=p>,</span> <span class=nx>inheritTime</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 这是窃取不到，但是知道有新的定时器工作到来没找到，所以重新开始
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>newWork</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// There may be new timer or GC work; restart to
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// discover.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>goto</span> <span class=nx>top</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>now</span> <span class=p>=</span> <span class=nx>tnow</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>w</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nx>pollUntil</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>w</span> <span class=p>&lt;</span> <span class=nx>pollUntil</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// Earlier timer to wait for.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>pollUntil</span> <span class=p>=</span> <span class=nx>w</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// We have nothing to do.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// If we&#39;re in the GC mark phase, can safely scan and blacken objects,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// and have work to do, run idle-time marking rather than give up the P.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 无事可做从 gc mark worker 中获取
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>gcBlackenEnabled</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nf>gcMarkWorkAvailable</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=nx>gcController</span><span class=p>.</span><span class=nf>addIdleMarkWorker</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>node</span> <span class=o>:=</span> <span class=p>(</span><span class=o>*</span><span class=nx>gcBgMarkWorkerNode</span><span class=p>)(</span><span class=nx>gcBgMarkWorkerPool</span><span class=p>.</span><span class=nf>pop</span><span class=p>())</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>node</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>pp</span><span class=p>.</span><span class=nx>gcMarkWorkerMode</span> <span class=p>=</span> <span class=nx>gcMarkWorkerIdleMode</span>
</span></span><span class=line><span class=cl>			<span class=nx>gp</span> <span class=o>:=</span> <span class=nx>node</span><span class=p>.</span><span class=nx>gp</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>_Gwaiting</span><span class=p>,</span> <span class=nx>_Grunnable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nf>traceEnabled</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nf>traceGoUnpark</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>gp</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>gcController</span><span class=p>.</span><span class=nf>removeIdleMarkWorker</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// wasm only:
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// If a callback returned and no other goroutine is awake,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// then wake event handler goroutine which pauses execution
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// until a callback was triggered.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>gp</span><span class=p>,</span> <span class=nx>otherReady</span> <span class=o>:=</span> <span class=nf>beforeIdle</span><span class=p>(</span><span class=nx>now</span><span class=p>,</span> <span class=nx>pollUntil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>gp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>_Gwaiting</span><span class=p>,</span> <span class=nx>_Grunnable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nf>traceEnabled</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>traceGoUnpark</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>gp</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>otherReady</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>goto</span> <span class=nx>top</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 没有任何可以获取的工作给 P，应该将当前 P 让给其他等待的 m
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// Before we drop our P, make a snapshot of the allp slice,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// which can change underfoot once we no longer block
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// safe-points. We don&#39;t need to snapshot the contents because
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// everything up to cap(allp) is immutable.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>allpSnapshot</span> <span class=o>:=</span> <span class=nx>allp</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Also snapshot masks. Value changes are OK, but we can&#39;t allow
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// len to change out from under us.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>idlepMaskSnapshot</span> <span class=o>:=</span> <span class=nx>idlepMask</span>
</span></span><span class=line><span class=cl>	<span class=nx>timerpMaskSnapshot</span> <span class=o>:=</span> <span class=nx>timerpMask</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// return P and block
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 有 gc 或者安全点工作需要执行，执行完当前 P 可能就能找到工作，所以重试一次
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>gcwaiting</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span> <span class=o>||</span> <span class=nx>pp</span><span class=p>.</span><span class=nx>runSafePointFn</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>goto</span> <span class=nx>top</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 查找过程中并不是一直锁定了全局调度器 sched，所以此时可能会有新的加入，尝试获取
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>runqsize</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>gp</span> <span class=o>:=</span> <span class=nf>globrunqget</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>gp</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 需要从非自旋切换到自旋，但是全局 needspinning = 1，阻止此次切换并 needspinning = 0
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>!</span><span class=nx>mp</span><span class=p>.</span><span class=nx>spinning</span> <span class=o>&amp;&amp;</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>needspinning</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// See &#34;Delicate dance&#34; comment below.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>mp</span><span class=p>.</span><span class=nf>becomeSpinning</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>goto</span> <span class=nx>top</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 释放 p
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nf>releasep</span><span class=p>()</span> <span class=o>!=</span> <span class=nx>pp</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;findrunnable: wrong p&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>now</span> <span class=p>=</span> <span class=nf>pidleput</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span> <span class=nx>now</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Delicate dance: thread transitions from spinning to non-spinning
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// state, potentially concurrently with submission of new work. We must
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// drop nmspinning first and then check all sources again (with
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// #StoreLoad memory barrier in between). If we do it the other way
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// around, another thread can submit work after we&#39;ve checked all
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// sources but before we drop nmspinning; as a result nobody will
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// unpark a thread to run the work.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// This applies to the following sources of work:
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// * Goroutines added to a per-P run queue.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// * New/modified-earlier timers on a per-P timer heap.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// * Idle-priority GC work (barring golang.org/issue/19112).
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// If we discover new work below, we need to restore m.spinning as a
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// signal for resetspinning to unpark a new worker thread (because
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// there can be more than one starving goroutine).
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// However, if after discovering new work we also observe no idle Ps
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// (either here or in resetspinning), we have a problem. We may be
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// racing with a non-spinning M in the block above, having found no
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// work and preparing to release its P and park. Allowing that P to go
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// idle will result in loss of work conservation (idle P while there is
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// runnable work). This could result in complete deadlock in the
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// unlikely event that we discover new work (from netpoll) right as we
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// are racing with _all_ other Ps going idle.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// We use sched.needspinning to synchronize with non-spinning Ms going
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// idle. If needspinning is set when they are about to drop their P,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// they abort the drop and instead become a new spinning M on our
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// behalf. If we are not racing and the system is truly fully loaded
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// then no spinning threads are required, and the next thread to
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// naturally become spinning will clear the flag.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Also see &#34;Worker thread parking/unparking&#34; comment at the top of the
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// file.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 开始从非自旋转换到自旋
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>wasSpinning</span> <span class=o>:=</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>spinning</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>spinning</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>mp</span><span class=p>.</span><span class=nx>spinning</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>nmspinning</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;findrunnable: negative nmspinning&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Note the for correctness, only the last M transitioning from
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// spinning to non-spinning must perform these rechecks to
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// ensure no missed work. However, the runtime has some cases
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// of transient increments of nmspinning that are decremented
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// without going through this path, so we must be conservative
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// and perform the check on all spinning Ms.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// See https://go.dev/issue/43997.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=c1>// Check all runqueues once again.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 尝试从其他 P 中窃取任务，窃取到先切换到自旋状态，重新开启调度
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>pp</span> <span class=o>:=</span> <span class=nf>checkRunqsNoP</span><span class=p>(</span><span class=nx>allpSnapshot</span><span class=p>,</span> <span class=nx>idlepMaskSnapshot</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>pp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>acquirep</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>mp</span><span class=p>.</span><span class=nf>becomeSpinning</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=k>goto</span> <span class=nx>top</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Check for idle-priority GC work again.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>pp</span><span class=p>,</span> <span class=nx>gp</span> <span class=o>:=</span> <span class=nf>checkIdleGCNoP</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>pp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>acquirep</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>mp</span><span class=p>.</span><span class=nf>becomeSpinning</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=c1>// Run the idle worker.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>pp</span><span class=p>.</span><span class=nx>gcMarkWorkerMode</span> <span class=p>=</span> <span class=nx>gcMarkWorkerIdleMode</span>
</span></span><span class=line><span class=cl>			<span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>_Gwaiting</span><span class=p>,</span> <span class=nx>_Grunnable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nf>traceEnabled</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nf>traceGoUnpark</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>gp</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Finally, check for timer creation or expiry concurrently with
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// transitioning from spinning to non-spinning.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// Note that we cannot use checkTimers here because it calls
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// adjusttimers which may need to allocate memory, and that isn&#39;t
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// allowed when we don&#39;t have an active P.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>pollUntil</span> <span class=p>=</span> <span class=nf>checkTimersNoP</span><span class=p>(</span><span class=nx>allpSnapshot</span><span class=p>,</span> <span class=nx>timerpMaskSnapshot</span><span class=p>,</span> <span class=nx>pollUntil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Poll network until next timer.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 从 poll 获取任务，无人无睡眠回到开始，有任务有 p 就锁定 p 防止抢占，再把第一个任务返回，其余放到全局，无 p 就全放全局
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nf>netpollinited</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nx>netpollWaiters</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>pollUntil</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>lastpoll</span><span class=p>.</span><span class=nf>Swap</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>sched</span><span class=p>.</span><span class=nx>pollUntil</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=nx>pollUntil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>p</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;findrunnable: netpoll with p&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>spinning</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;findrunnable: netpoll with spinning&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>delay</span> <span class=o>:=</span> <span class=nb>int64</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>pollUntil</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>now</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>now</span> <span class=p>=</span> <span class=nf>nanotime</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>delay</span> <span class=p>=</span> <span class=nx>pollUntil</span> <span class=o>-</span> <span class=nx>now</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>delay</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>delay</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>faketime</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// When using fake time, just poll.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>delay</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>list</span> <span class=o>:=</span> <span class=nf>netpoll</span><span class=p>(</span><span class=nx>delay</span><span class=p>)</span> <span class=c1>// block until new work is available
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// Refresh now again, after potentially blocking.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>now</span> <span class=p>=</span> <span class=nf>nanotime</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>sched</span><span class=p>.</span><span class=nx>pollUntil</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>sched</span><span class=p>.</span><span class=nx>lastpoll</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=nx>now</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>faketime</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>list</span><span class=p>.</span><span class=nf>empty</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// Using fake time and nothing is ready; stop M.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// When all M&#39;s stop, checkdead will call timejump.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nf>stopm</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=k>goto</span> <span class=nx>top</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>pp</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nf>pidleget</span><span class=p>(</span><span class=nx>now</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>pp</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>injectglist</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>acquirep</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>!</span><span class=nx>list</span><span class=p>.</span><span class=nf>empty</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>gp</span> <span class=o>:=</span> <span class=nx>list</span><span class=p>.</span><span class=nf>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>				<span class=nf>injectglist</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>_Gwaiting</span><span class=p>,</span> <span class=nx>_Grunnable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nf>traceEnabled</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nf>traceGoUnpark</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=nx>gp</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>wasSpinning</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>mp</span><span class=p>.</span><span class=nf>becomeSpinning</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>goto</span> <span class=nx>top</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>pollUntil</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nf>netpollinited</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>pollerPollUntil</span> <span class=o>:=</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>pollUntil</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>pollerPollUntil</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>pollerPollUntil</span> <span class=p>&gt;</span> <span class=nx>pollUntil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>netpollBreak</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>stopm</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>goto</span> <span class=nx>top</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>核心分成两块，前半部分是直接找能找到 <code>g</code> 直接返回，当找不到时，由于并发运行，可能在寻找过程中有新的 <code>g</code> 可以获取，所以后半部分就是先尝试将当前 <code>m</code> 变为自旋，只是 <code>m</code> 的状态标记改变，实际线程并没有自旋，原因源代码的注释解释的很清楚，防止竞争导致死锁或者任务调度出现延迟，之后再尝试获取任务 <code>g</code>，如果这时候还是无法获取到，那就真的线程陷入自旋，等待唤醒后重新尝试获取。</p><ol><li>从 <code>gc</code> 尝试获取</li><li>每 61 次调度从全局队列获取</li><li>本地队列</li><li>全局队列</li><li><code>netpoll</code> 获取</li><li>窃取其他 <code>p</code> 上的</li><li>辅助 <code>gc</code> 标记任务</li><li>全局</li><li><code>gc</code></li><li><code>netpoll</code></li></ol><p>为什么要设计成这样？后半部分完全可以先休眠让出 <code>P</code>，期间产生的任务下次调度时也可以找到，我的猜测是为了降低任务调度延时和吞吐量</p><h2 id=怎么开始执行-g>怎么开始执行 <code>g</code></h2><p>执行从 <code>execute</code> 函数开始</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// [runtime/proc.go]
</span></span></span><span class=line><span class=cl><span class=c1>// Schedules gp to run on the current M.
</span></span></span><span class=line><span class=cl><span class=c1>// If inheritTime is true, gp inherits the remaining time in the
</span></span></span><span class=line><span class=cl><span class=c1>// current time slice. Otherwise, it starts a new time slice.
</span></span></span><span class=line><span class=cl><span class=c1>// Never returns.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Write barriers are allowed because this is called immediately after
</span></span></span><span class=line><span class=cl><span class=c1>// acquiring a P in several places.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//go:yeswritebarrierrec
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>execute</span><span class=p>(</span><span class=nx>gp</span> <span class=o>*</span><span class=nx>g</span><span class=p>,</span> <span class=nx>inheritTime</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>mp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>().</span><span class=nx>m</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>goroutineProfile</span><span class=p>.</span><span class=nx>active</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Make sure that gp has had its stack written out to the goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// profile, exactly as it was when the goroutine profiler first stopped
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// the world.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>tryRecordGoroutineProfile</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>osyield</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Assign gp.m before entering _Grunning so running Gs have an
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// M.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>mp</span><span class=p>.</span><span class=nx>curg</span> <span class=p>=</span> <span class=nx>gp</span> <span class=c1>// 更新 curg 到当前 g
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>gp</span><span class=p>.</span><span class=nx>m</span> <span class=p>=</span> <span class=nx>mp</span> <span class=c1>// 双向绑定
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>_Grunnable</span><span class=p>,</span> <span class=nx>_Grunning</span><span class=p>)</span> <span class=c1>// 切换状态到运行中
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>gp</span><span class=p>.</span><span class=nx>waitsince</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>preempt</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>stackguard0</span> <span class=p>=</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>lo</span> <span class=o>+</span> <span class=nx>stackGuard</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 不继承上个 g 的时间片
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>!</span><span class=nx>inheritTime</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>mp</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>().</span><span class=nx>schedtick</span><span class=o>++</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Check whether the profiler needs to be turned on or off.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>hz</span> <span class=o>:=</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>profilehz</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>profilehz</span> <span class=o>!=</span> <span class=nx>hz</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>setThreadCPUProfiler</span><span class=p>(</span><span class=nx>hz</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nf>traceEnabled</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// GoSysExit has to happen when we have a P, but before GoStart.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// So we emit it here.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>syscallsp</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>traceGoSysExit</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nf>traceGoStart</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>gogo</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>gp</span><span class=p>.</span><span class=nx>sched</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// [runtime/asm_amd64.s]
</span></span></span><span class=line><span class=cl><span class=c1>// func gogo(buf *gobuf)
</span></span></span><span class=line><span class=cl><span class=c1>// restore state from Gobuf; longjmp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>TEXT</span> <span class=nx>runtime</span><span class=err>·</span><span class=nf>gogo</span><span class=p>(</span><span class=nx>SB</span><span class=p>),</span> <span class=nx>NOSPLIT</span><span class=p>,</span> <span class=err>$</span><span class=mi>0</span><span class=o>-</span><span class=mi>8</span>
</span></span><span class=line><span class=cl>	<span class=nx>MOVQ</span>	<span class=nx>buf</span><span class=o>+</span><span class=mi>0</span><span class=p>(</span><span class=nx>FP</span><span class=p>),</span> <span class=nx>BX</span>		<span class=c1>// gobuf
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nf>gobuf_g</span><span class=p>(</span><span class=nx>BX</span><span class=p>),</span> <span class=nx>DX</span>     <span class=c1>// 当前的 g 的地址, g.sched.g
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=mi>0</span><span class=p>(</span><span class=nx>DX</span><span class=p>),</span> <span class=nx>CX</span>		<span class=c1>// make sure g != nil  // CX = &amp;g
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>JMP</span>	<span class=nx>gogo</span><span class=p>&lt;&gt;(</span><span class=nx>SB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>TEXT</span> <span class=nx>gogo</span><span class=p>&lt;&gt;(</span><span class=nx>SB</span><span class=p>),</span> <span class=nx>NOSPLIT</span><span class=p>,</span> <span class=err>$</span><span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=nf>get_tls</span><span class=p>(</span><span class=nx>CX</span><span class=p>)</span>                 <span class=c1>// CX = TLS
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nx>DX</span><span class=p>,</span> <span class=nf>g</span><span class=p>(</span><span class=nx>CX</span><span class=p>)</span>           <span class=c1>// TLS.g = g
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nx>DX</span><span class=p>,</span> <span class=nx>R14</span>		<span class=c1>// set the g register // R14 = g
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nf>gobuf_sp</span><span class=p>(</span><span class=nx>BX</span><span class=p>),</span> <span class=nx>SP</span>	<span class=c1>// restore SP // g 的 sp
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nf>gobuf_ret</span><span class=p>(</span><span class=nx>BX</span><span class=p>),</span> <span class=nx>AX</span>           <span class=c1>// 返回地址
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nf>gobuf_ctxt</span><span class=p>(</span><span class=nx>BX</span><span class=p>),</span> <span class=nx>DX</span> <span class=c1>// ctxt = fn
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nf>gobuf_bp</span><span class=p>(</span><span class=nx>BX</span><span class=p>),</span> <span class=nx>BP</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 清空 gobuf，方便 gc
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=err>$</span><span class=mi>0</span><span class=p>,</span> <span class=nf>gobuf_sp</span><span class=p>(</span><span class=nx>BX</span><span class=p>)</span>	<span class=c1>// clear to help garbage collector
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=err>$</span><span class=mi>0</span><span class=p>,</span> <span class=nf>gobuf_ret</span><span class=p>(</span><span class=nx>BX</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>MOVQ</span>	<span class=err>$</span><span class=mi>0</span><span class=p>,</span> <span class=nf>gobuf_ctxt</span><span class=p>(</span><span class=nx>BX</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>MOVQ</span>	<span class=err>$</span><span class=mi>0</span><span class=p>,</span> <span class=nf>gobuf_bp</span><span class=p>(</span><span class=nx>BX</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>MOVQ</span>	<span class=nf>gobuf_pc</span><span class=p>(</span><span class=nx>BX</span><span class=p>),</span> <span class=nx>BX</span> <span class=c1>// 绑定的 fn 函数的第一个指令的地址
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>JMP</span>	<span class=nx>BX</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=怎么退出-g-并开启下次调度>怎么退出 <code>g</code> 并开启下次调度</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// [runtime/asm.amd64.s]
</span></span></span><span class=line><span class=cl><span class=c1>// The top-most function running on a goroutine
</span></span></span><span class=line><span class=cl><span class=c1>// returns to goexit+PCQuantum.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>TEXT</span> <span class=nx>runtime</span><span class=err>·</span><span class=nf>goexit</span><span class=p>(</span><span class=nx>SB</span><span class=p>),</span><span class=nx>NOSPLIT</span><span class=p>|</span><span class=nx>TOPFRAME</span><span class=p>|</span><span class=nx>NOFRAME</span><span class=p>,</span><span class=err>$</span><span class=mi>0</span><span class=o>-</span><span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=nx>BYTE</span>	<span class=err>$</span><span class=mh>0x90</span>	<span class=c1>// NOP
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>CALL</span>	<span class=nx>runtime</span><span class=err>·</span><span class=nf>goexit1</span><span class=p>(</span><span class=nx>SB</span><span class=p>)</span>	<span class=c1>// does not return // 实际调用 goexit1
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// traceback from goexit1 must hit code range of goexit
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>BYTE</span>	<span class=err>$</span><span class=mh>0x90</span>	<span class=c1>// NOP
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// func mcall(fn func(*g))
</span></span></span><span class=line><span class=cl><span class=c1>// Switch to m-&gt;g0&#39;s stack, call fn(g).
</span></span></span><span class=line><span class=cl><span class=c1>// Fn must never return. It should gogo(&amp;g-&gt;sched)
</span></span></span><span class=line><span class=cl><span class=c1>// to keep running g.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>TEXT</span> <span class=nx>runtime</span><span class=err>·</span><span class=nx>mcall</span><span class=p>&lt;</span><span class=nx>ABIInternal</span><span class=p>&gt;(</span><span class=nx>SB</span><span class=p>),</span> <span class=nx>NOSPLIT</span><span class=p>,</span> <span class=err>$</span><span class=mi>0</span><span class=o>-</span><span class=mi>8</span>
</span></span><span class=line><span class=cl>	<span class=nx>MOVQ</span>	<span class=nx>AX</span><span class=p>,</span> <span class=nx>DX</span>	<span class=c1>// DX = fn
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// Save state in g-&gt;sched. The caller&#39;s SP and PC are restored by gogo to
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// resume execution in the caller&#39;s frame (implicit return). The caller&#39;s BP
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// is also restored to support frame pointer unwinding.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nx>SP</span><span class=p>,</span> <span class=nx>BX</span>	<span class=c1>// hide (SP) reads from vet
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=mi>8</span><span class=p>(</span><span class=nx>BX</span><span class=p>),</span> <span class=nx>BX</span>	<span class=c1>// caller&#39;s PC
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nx>BX</span><span class=p>,</span> <span class=p>(</span><span class=nx>g_sched</span><span class=o>+</span><span class=nx>gobuf_pc</span><span class=p>)(</span><span class=nx>R14</span><span class=p>)</span> <span class=c1>// r14 放的 g，g.sched.pc = BX，存了 caller pc
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>LEAQ</span>	<span class=nx>fn</span><span class=o>+</span><span class=mi>0</span><span class=p>(</span><span class=nx>FP</span><span class=p>),</span> <span class=nx>BX</span>	<span class=c1>// caller&#39;s SP
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nx>BX</span><span class=p>,</span> <span class=p>(</span><span class=nx>g_sched</span><span class=o>+</span><span class=nx>gobuf_sp</span><span class=p>)(</span><span class=nx>R14</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Get the caller&#39;s frame pointer by dereferencing BP. Storing BP as it is
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// can cause a frame pointer cycle, see CL 476235.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>MOVQ</span>	<span class=p>(</span><span class=nx>BP</span><span class=p>),</span> <span class=nx>BX</span> <span class=c1>// caller&#39;s BP
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nx>BX</span><span class=p>,</span> <span class=p>(</span><span class=nx>g_sched</span><span class=o>+</span><span class=nx>gobuf_bp</span><span class=p>)(</span><span class=nx>R14</span><span class=p>)</span> <span class=c1>// g.sched.bp = caller&#39;s BP
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// switch to m-&gt;g0 &amp; its stack, call fn
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nf>g_m</span><span class=p>(</span><span class=nx>R14</span><span class=p>),</span> <span class=nx>BX</span>    <span class=c1>// BX = g.m
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nf>m_g0</span><span class=p>(</span><span class=nx>BX</span><span class=p>),</span> <span class=nx>SI</span>	<span class=c1>// SI = g.m.g0
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>CMPQ</span>	<span class=nx>SI</span><span class=p>,</span> <span class=nx>R14</span>	<span class=c1>// if g == m-&gt;g0 call badmcall // 调用者是 g0，抛出错误
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>JNE</span>	<span class=nx>goodm</span>
</span></span><span class=line><span class=cl>	<span class=nx>JMP</span>	<span class=nx>runtime</span><span class=err>·</span><span class=nf>badmcall</span><span class=p>(</span><span class=nx>SB</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>goodm</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=nx>MOVQ</span>	<span class=nx>R14</span><span class=p>,</span> <span class=nx>AX</span>		<span class=c1>// AX (and arg 0) = g
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nx>SI</span><span class=p>,</span> <span class=nx>R14</span>		<span class=c1>// g = g.m.g0
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>get_tls</span><span class=p>(</span><span class=nx>CX</span><span class=p>)</span>		<span class=c1>// Set G in TLS // CX = TLS
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=nx>R14</span><span class=p>,</span> <span class=nf>g</span><span class=p>(</span><span class=nx>CX</span><span class=p>)</span> <span class=c1>// TLS.g = g0 在 TLS 记录当前 g
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>MOVQ</span>	<span class=p>(</span><span class=nx>g_sched</span><span class=o>+</span><span class=nx>gobuf_sp</span><span class=p>)(</span><span class=nx>R14</span><span class=p>),</span> <span class=nx>SP</span>	<span class=c1>// sp = g0.sched.sp
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>PUSHQ</span>	<span class=nx>AX</span>	<span class=c1>// open up space for fn&#39;s arg spill slot // g 入栈作为参数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MOVQ</span>	<span class=mi>0</span><span class=p>(</span><span class=nx>DX</span><span class=p>),</span> <span class=nx>R12</span> <span class=c1>// R12 = fn
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>CALL</span>	<span class=nx>R12</span>		<span class=c1>// fn(g)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>POPQ</span>	<span class=nx>AX</span> <span class=c1>// 调用结束出栈
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>JMP</span>	<span class=nx>runtime</span><span class=err>·</span><span class=nf>badmcall2</span><span class=p>(</span><span class=nx>SB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>RET</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// [runtime/proc.go]
</span></span></span><span class=line><span class=cl><span class=c1>// Finishes execution of the current goroutine.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>goexit1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>raceenabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>racegoend</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nf>traceEnabled</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>traceGoEnd</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>mcall</span><span class=p>(</span><span class=nx>goexit0</span><span class=p>)</span> <span class=c1>// 切换到 g0 上执行 goexit0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// goexit continuation on g0.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>goexit0</span><span class=p>(</span><span class=nx>gp</span> <span class=o>*</span><span class=nx>g</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>mp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>().</span><span class=nx>m</span>
</span></span><span class=line><span class=cl>	<span class=nx>pp</span> <span class=o>:=</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>_Grunning</span><span class=p>,</span> <span class=nx>_Gdead</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// g 的栈可以被清理
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>gcController</span><span class=p>.</span><span class=nf>addScannableStack</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span> <span class=o>-</span><span class=nb>int64</span><span class=p>(</span><span class=nx>gp</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>hi</span><span class=o>-</span><span class=nx>gp</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>lo</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nf>isSystemGoroutine</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=kc>false</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>sched</span><span class=p>.</span><span class=nx>ngsys</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 释放其他引用的资源，方便 gc
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>gp</span><span class=p>.</span><span class=nx>m</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=nx>locked</span> <span class=o>:=</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>lockedm</span> <span class=o>!=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>lockedm</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=nx>mp</span><span class=p>.</span><span class=nx>lockedg</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>preemptStop</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>paniconfault</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>_defer</span> <span class=p>=</span> <span class=kc>nil</span> <span class=c1>// should be true already but just in case.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>gp</span><span class=p>.</span><span class=nx>_panic</span> <span class=p>=</span> <span class=kc>nil</span> <span class=c1>// non-nil for Goexit during panic. points at stack-allocated data.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>gp</span><span class=p>.</span><span class=nx>writebuf</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>waitreason</span> <span class=p>=</span> <span class=nx>waitReasonZero</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>param</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>labels</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>timer</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>gcBlackenEnabled</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>gcAssistBytes</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Flush assist credit to the global pool. This gives
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// better information to pacing if the application is
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// rapidly creating an exiting goroutines.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>assistWorkPerByte</span> <span class=o>:=</span> <span class=nx>gcController</span><span class=p>.</span><span class=nx>assistWorkPerByte</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>scanCredit</span> <span class=o>:=</span> <span class=nb>int64</span><span class=p>(</span><span class=nx>assistWorkPerByte</span> <span class=o>*</span> <span class=nb>float64</span><span class=p>(</span><span class=nx>gp</span><span class=p>.</span><span class=nx>gcAssistBytes</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=nx>gcController</span><span class=p>.</span><span class=nx>bgScanCredit</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=nx>scanCredit</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>gp</span><span class=p>.</span><span class=nx>gcAssistBytes</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>dropg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>GOARCH</span> <span class=o>==</span> <span class=s>&#34;wasm&#34;</span> <span class=p>{</span> <span class=c1>// no threads yet on wasm
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>gfput</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span> <span class=nx>gp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>schedule</span><span class=p>()</span> <span class=c1>// never returns
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>lockedInt</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>print</span><span class=p>(</span><span class=s>&#34;invalid m-&gt;lockedInt = &#34;</span><span class=p>,</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>lockedInt</span><span class=p>,</span> <span class=s>&#34;\n&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;internal lockOSThread error&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 但是 g 结构体本身不是立即给 gc 销毁，而是放到 p 的 gFree 上，方便下次分配
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>gfput</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span> <span class=nx>gp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>locked</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// The goroutine may have locked this thread because
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// it put it in an unusual kernel state. Kill it
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// rather than returning it to the thread pool.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=c1>// Return to mstart, which will release the P and exit
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// the thread.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>GOOS</span> <span class=o>!=</span> <span class=s>&#34;plan9&#34;</span> <span class=p>{</span> <span class=c1>// See golang.org/issue/22227.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nf>gogo</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>mp</span><span class=p>.</span><span class=nx>g0</span><span class=p>.</span><span class=nx>sched</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// Clear lockedExt on plan9 since we may end up re-using
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// this thread.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>mp</span><span class=p>.</span><span class=nx>lockedExt</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 完美，下次调度开启，调度是惰性的，而不是 reactor 循环事件
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>schedule</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>g</code> 释放时仅释放所有引用的资源，但是自身结构体可以放到 <code>p.gFree</code> 中缓存，加速下次创建分配</li><li><code>g</code> 最后开启下一轮调度，说明调度是惰性的</li></ul><h2 id=回到第一个真正的-g>回到第一个真正的 <code>g</code></h2><p>以上问题搞清楚之后，再回来看第一个 <code>g</code> 干了啥，第一个 <code>g</code> 是运行时整体环境构建的开始</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// The main goroutine.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>mp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>().</span><span class=nx>m</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Racectx of m0-&gt;g0 is used only as the parent of the main goroutine.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// It must not be used for anything else.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>mp</span><span class=p>.</span><span class=nx>g0</span><span class=p>.</span><span class=nx>racectx</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Using decimal instead of binary GB and MB because
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// they look nicer in the stack overflow failure message.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>goarch</span><span class=p>.</span><span class=nx>PtrSize</span> <span class=o>==</span> <span class=mi>8</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>maxstacksize</span> <span class=p>=</span> <span class=mi>1000000000</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>maxstacksize</span> <span class=p>=</span> <span class=mi>250000000</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// An upper limit for max stack size. Used to avoid random crashes
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// after calling SetMaxStack and trying to allocate a stack that is too big,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// since stackalloc works with 32-bit sizes.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>maxstackceiling</span> <span class=p>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=nx>maxstacksize</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Allow newproc to start new Ms.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>mainStarted</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 启动系统监控，这里也开始创建第二个 m
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>GOARCH</span> <span class=o>!=</span> <span class=s>&#34;wasm&#34;</span> <span class=p>{</span> <span class=c1>// no threads on wasm yet, so no sysmon
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>systemstack</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>newm</span><span class=p>(</span><span class=nx>sysmon</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Lock the main goroutine onto this, the main OS thread,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// during initialization. Most programs won&#39;t care, but a few
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// do require certain calls to be made by the main thread.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Those can arrange for main.main to run in the main thread
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// by calling runtime.LockOSThread during initialization
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// to preserve the lock.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>lockOSThread</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>mp</span> <span class=o>!=</span> <span class=o>&amp;</span><span class=nx>m0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;runtime.main not on m0&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Record when the world started.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Must be before doInit for tracing init.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>runtimeInitTime</span> <span class=p>=</span> <span class=nf>nanotime</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>runtimeInitTime</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;nanotime returning zero&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>debug</span><span class=p>.</span><span class=nx>inittrace</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>inittrace</span><span class=p>.</span><span class=nx>id</span> <span class=p>=</span> <span class=nf>getg</span><span class=p>().</span><span class=nx>goid</span>
</span></span><span class=line><span class=cl>		<span class=nx>inittrace</span><span class=p>.</span><span class=nx>active</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 运行时初始化工作，不是用户代码的 init
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>doInit</span><span class=p>(</span><span class=nx>runtime_inittasks</span><span class=p>)</span> <span class=c1>// Must be before defer.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// Defer unlock so that runtime.Goexit during init does the unlock too.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>needUnlock</span> <span class=o>:=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>needUnlock</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>unlockOSThread</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 开启 gc
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>gcenable</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 给 cgo 用的
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>main_init_done</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>iscgo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>_cgo_pthread_key_created</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;_cgo_pthread_key_created missing&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>_cgo_thread_start</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;_cgo_thread_start missing&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>GOOS</span> <span class=o>!=</span> <span class=s>&#34;windows&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>_cgo_setenv</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;_cgo_setenv missing&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>_cgo_unsetenv</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;_cgo_unsetenv missing&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>_cgo_notify_runtime_init_done</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;_cgo_notify_runtime_init_done missing&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Set the x_crosscall2_ptr C function pointer variable point to crosscall2.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>set_crosscall2</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;set_crosscall2 missing&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nf>set_crosscall2</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Start the template thread in case we enter Go from
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// a C-created thread and need to create a new thread.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>startTemplateThread</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nf>cgocall</span><span class=p>(</span><span class=nx>_cgo_notify_runtime_init_done</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Run the initializing tasks. Depending on build mode this
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// list can arrive a few different ways, but it will always
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// contain the init tasks computed by the linker for all the
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// packages in the program (excluding those added at runtime
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// by package plugin).
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 这里才是用户代码的 init 函数，包括各种包的
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>m</span> <span class=o>:=</span> <span class=k>range</span> <span class=nf>activeModules</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>doInit</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>inittasks</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Disable init tracing after main init done to avoid overhead
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// of collecting statistics in malloc and newproc
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>inittrace</span><span class=p>.</span><span class=nx>active</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nb>close</span><span class=p>(</span><span class=nx>main_init_done</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>needUnlock</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=nf>unlockOSThread</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>isarchive</span> <span class=o>||</span> <span class=nx>islibrary</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// A program compiled with -buildmode=c-archive or c-shared
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// has a main, but it is not executed.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 用户空间的 main 函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fn</span> <span class=o>:=</span> <span class=nx>main_main</span> <span class=c1>// make an indirect call, as the linker doesn&#39;t know the address of the main package when laying down the runtime
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>fn</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>raceenabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>runExitHooks</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=c1>// run hooks now, since racefini does not return
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>racefini</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Make racy client program work: if panicking on
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// another goroutine at the same time as main returns,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// let the other goroutine finish printing the panic trace.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Once it does, it will exit. See issues 3934 and 20018.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 优先打印主函数之外的协程的 panic defer 信息
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>runningPanicDefers</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Running deferred functions should not take long.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>for</span> <span class=nx>c</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>c</span> <span class=p>&lt;</span> <span class=mi>1000</span><span class=p>;</span> <span class=nx>c</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>runningPanicDefers</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>break</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nf>Gosched</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 还有函数正在执行 panic，继续开启调度直到结束
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>panicking</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>gopark</span><span class=p>(</span><span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>waitReasonPanicWait</span><span class=p>,</span> <span class=nx>traceBlockForever</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 通过 runtime.addExitHooks 添加的回调
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>runExitHooks</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 真正结束当前线程
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 下面的代码不该被运行到
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=nx>x</span> <span class=o>*</span><span class=kt>int32</span>
</span></span><span class=line><span class=cl>		<span class=o>*</span><span class=nx>x</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>这里先用另一个 <code>m</code> 启动系统监控，系统监控的执行不需要 <code>p</code></li><li>再开启 <code>gc</code></li><li>最后运行用户的 <code>main</code> 函数</li><li>当前函数退出时，整个函数的生命周期结束，这也就是为什么用户代码的 <code>main</code> 中经常需要在最后阻塞住</li></ul><h2 id=漏了什么怎么暂停-g-再开始>漏了什么？怎么暂停 <code>g</code> 再开始</h2><p>上边 <code>main</code> 中 153 行，由于 <code>panic</code> 还未结束，所以为了等待，选择了 <code>gopark</code>，这就是暂停当前 <code>g</code> 的执行，一定时候 <code>g</code> 不能一次性执行完到结束，而是多次调度到生命周期完结，接下来找下所有调用 <code>gopark</code> 的函数，找到所有可能暂停 <code>g</code> 的时候</p><ul><li><code>[runtime/chan.go] chanrecv chansend</code>: <code>channel</code> 收发阻塞</li><li><code>[runtime/select.go] block selectgo</code>: 同上</li><li><code>[runtime/mfinal.go] runfinq</code>: finalizer 列表为空</li><li><code>[runtime/mgc.go] gcBgMarkWorker</code>: gc 后台标记是阶段性任务</li><li><code>[runtime/netpoll.go] netpollBlock</code>: 网络轮训器等待</li><li><code>[runtime/proc.go] goparkunlock</code>: 取消 <code>gopark</code> 的锁定，使得可以用 <code>goready</code> 再次加入调度</li><li><code>[runtime/time.go] timeSleep</code>: 休眠协程</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Puts the current goroutine into a waiting state and calls unlockf on the
</span></span></span><span class=line><span class=cl><span class=c1>// system stack.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// If unlockf returns false, the goroutine is resumed.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// unlockf must not access this G&#39;s stack, as it may be moved between
</span></span></span><span class=line><span class=cl><span class=c1>// the call to gopark and the call to unlockf.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Note that because unlockf is called after putting the G into a waiting
</span></span></span><span class=line><span class=cl><span class=c1>// state, the G may have already been readied by the time unlockf is called
</span></span></span><span class=line><span class=cl><span class=c1>// unless there is external synchronization preventing the G from being
</span></span></span><span class=line><span class=cl><span class=c1>// readied. If unlockf returns false, it must guarantee that the G cannot be
</span></span></span><span class=line><span class=cl><span class=c1>// externally readied.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Reason explains why the goroutine has been parked. It is displayed in stack
</span></span></span><span class=line><span class=cl><span class=c1>// traces and heap dumps. Reasons should be unique and descriptive. Do not
</span></span></span><span class=line><span class=cl><span class=c1>// re-use reasons, add new ones.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>gopark</span><span class=p>(</span><span class=nx>unlockf</span> <span class=kd>func</span><span class=p>(</span><span class=o>*</span><span class=nx>g</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>lock</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>reason</span> <span class=nx>waitReason</span><span class=p>,</span> <span class=nx>traceReason</span> <span class=nx>traceBlockReason</span><span class=p>,</span> <span class=nx>traceskip</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>reason</span> <span class=o>!=</span> <span class=nx>waitReasonSleep</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>checkTimeouts</span><span class=p>()</span> <span class=c1>// timeouts may expire while two goroutines keep the scheduler busy
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>mp</span> <span class=o>:=</span> <span class=nf>acquirem</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span> <span class=o>:=</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>curg</span>
</span></span><span class=line><span class=cl>	<span class=nx>status</span> <span class=o>:=</span> <span class=nf>readgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>status</span> <span class=o>!=</span> <span class=nx>_Grunning</span> <span class=o>&amp;&amp;</span> <span class=nx>status</span> <span class=o>!=</span> <span class=nx>_Gscanrunning</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;gopark: bad g status&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>mp</span><span class=p>.</span><span class=nx>waitlock</span> <span class=p>=</span> <span class=nx>lock</span>
</span></span><span class=line><span class=cl>	<span class=nx>mp</span><span class=p>.</span><span class=nx>waitunlockf</span> <span class=p>=</span> <span class=nx>unlockf</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>waitreason</span> <span class=p>=</span> <span class=nx>reason</span>
</span></span><span class=line><span class=cl>	<span class=nx>mp</span><span class=p>.</span><span class=nx>waitTraceBlockReason</span> <span class=p>=</span> <span class=nx>traceReason</span>
</span></span><span class=line><span class=cl>	<span class=nx>mp</span><span class=p>.</span><span class=nx>waitTraceSkip</span> <span class=p>=</span> <span class=nx>traceskip</span>
</span></span><span class=line><span class=cl>	<span class=nf>releasem</span><span class=p>(</span><span class=nx>mp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// can&#39;t do anything that might move the G between Ms here.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>mcall</span><span class=p>(</span><span class=nx>park_m</span><span class=p>)</span> <span class=c1>// 切换到 g0 栈上执行
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// park continuation on g0.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>park_m</span><span class=p>(</span><span class=nx>gp</span> <span class=o>*</span><span class=nx>g</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>mp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>().</span><span class=nx>m</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nf>traceEnabled</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>traceGoPark</span><span class=p>(</span><span class=nx>mp</span><span class=p>.</span><span class=nx>waitTraceBlockReason</span><span class=p>,</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>waitTraceSkip</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// N.B. Not using casGToWaiting here because the waitreason is
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// set by park_m&#39;s caller.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>_Grunning</span><span class=p>,</span> <span class=nx>_Gwaiting</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 从 m 中解开 g 的引用
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>dropg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 可能这时已经满足 g 运行的条件，再次确认下
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>fn</span> <span class=o>:=</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>waitunlockf</span><span class=p>;</span> <span class=nx>fn</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>ok</span> <span class=o>:=</span> <span class=nf>fn</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>waitlock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>mp</span><span class=p>.</span><span class=nx>waitunlockf</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=nx>mp</span><span class=p>.</span><span class=nx>waitlock</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nf>traceEnabled</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nf>traceGoUnpark</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>_Gwaiting</span><span class=p>,</span> <span class=nx>_Grunnable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nf>execute</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span> <span class=c1>// Schedule it back, never returns.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>schedule</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>gopark</code> 只是让 <code>g</code> 脱离当前 <code>m</code>，并不负责处理 <code>g</code> 的去向，<code>g</code> 的保存需要调用者处理，同样 <code>g</code> 的再次启动也要调用者提供可启动的 <code>g</code>，然后给 <code>goready</code> 绑定 <code>g</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>goready</span><span class=p>(</span><span class=nx>gp</span> <span class=o>*</span><span class=nx>g</span><span class=p>,</span> <span class=nx>traceskip</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>systemstack</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>ready</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>traceskip</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Mark gp ready to run.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>ready</span><span class=p>(</span><span class=nx>gp</span> <span class=o>*</span><span class=nx>g</span><span class=p>,</span> <span class=nx>traceskip</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>next</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nf>traceEnabled</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>traceGoUnpark</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>traceskip</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>status</span> <span class=o>:=</span> <span class=nf>readgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Mark runnable.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>mp</span> <span class=o>:=</span> <span class=nf>acquirem</span><span class=p>()</span> <span class=c1>// disable preemption because it can be holding p in a local var
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>status</span><span class=o>&amp;^</span><span class=nx>_Gscan</span> <span class=o>!=</span> <span class=nx>_Gwaiting</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>dumpgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;bad g-&gt;status in ready&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// status is Gwaiting or Gscanwaiting, make Grunnable and put on runq
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>_Gwaiting</span><span class=p>,</span> <span class=nx>_Grunnable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// g 放入当前 p 上等待调度
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>runqput</span><span class=p>(</span><span class=nx>mp</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>(),</span> <span class=nx>gp</span><span class=p>,</span> <span class=nx>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>wakep</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nf>releasem</span><span class=p>(</span><span class=nx>mp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=之后-m-的创建和调度>之后 <code>m</code> 的创建和调度</h1><h2 id=m-的创建><code>m</code> 的创建</h2><p>如果读 <code>[runtime/proc.go]</code> 开头的说明，可以知道创建新 <code>m</code> 的时刻有两个</p><ul><li>平衡 <code>g</code> 和 <code>p</code> 的关系，让 <code>g</code> 尽可能均衡的跑在不同的 cpu 上，所以每 <code>go</code> 出一个协程时 <code>wakep</code> 创建 <code>m</code> 直到用完 <code>p</code></li><li>减少 <code>g</code> 因为新建调度等转移到新 <code>m</code> 上的等待时间，预先创建冗余的 <code>m</code>。每当 <code>sched.nmsping</code> 为 0 时，就额外创建一个 <code>m</code>。</li></ul><p>进入 <code>wakep</code> 看下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// [runtime/proc.go]
</span></span></span><span class=line><span class=cl><span class=c1>// Tries to add one more P to execute G&#39;s.
</span></span></span><span class=line><span class=cl><span class=c1>// Called when a G is made runnable (newproc, ready).
</span></span></span><span class=line><span class=cl><span class=c1>// Must be called with a P.
</span></span></span><span class=line><span class=cl><span class=c1>// 这段注释说明 ready 函数也会执行 wakep
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>wakep</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Be conservative about spinning threads, only start one if none exist
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// already.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 有在自旋的 m 就不尝试
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>nmspinning</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>||</span> <span class=p>!</span><span class=nx>sched</span><span class=p>.</span><span class=nx>nmspinning</span><span class=p>.</span><span class=nf>CompareAndSwap</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Disable preemption until ownership of pp transfers to the next M in
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// startm. Otherwise preemption here would leave pp stuck waiting to
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// enter _Pgcstop.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// See preemption comment on acquirem in startm for more details.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>mp</span> <span class=o>:=</span> <span class=nf>acquirem</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>pp</span> <span class=o>*</span><span class=nx>p</span>
</span></span><span class=line><span class=cl>	<span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 寻找空闲的 p
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>pp</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nf>pidlegetSpinning</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 找不到返回
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>pp</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>nmspinning</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;wakep: negative nmspinning&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>releasem</span><span class=p>(</span><span class=nx>mp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Since we always have a P, the race in the &#34;No M is available&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// comment in startm doesn&#39;t apply during the small window between the
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// unlock here and lock in startm. A checkdead in between will always
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// see at least one running M (ours).
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 为找到的 p 找 m 运行
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>startm</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=kc>false</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>releasem</span><span class=p>(</span><span class=nx>mp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Schedules some M to run the p (creates an M if necessary).
</span></span></span><span class=line><span class=cl><span class=c1>// If p==nil, tries to get an idle P, if no idle P&#39;s does nothing.
</span></span></span><span class=line><span class=cl><span class=c1>// May run with m.p==nil, so write barriers are not allowed.
</span></span></span><span class=line><span class=cl><span class=c1>// If spinning is set, the caller has incremented nmspinning and must provide a
</span></span></span><span class=line><span class=cl><span class=c1>// P. startm will set m.spinning in the newly started M.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Callers passing a non-nil P must call from a non-preemptible context. See
</span></span></span><span class=line><span class=cl><span class=c1>// comment on acquirem below.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Argument lockheld indicates whether the caller already acquired the
</span></span></span><span class=line><span class=cl><span class=c1>// scheduler lock. Callers holding the lock when making the call must pass
</span></span></span><span class=line><span class=cl><span class=c1>// true. The lock might be temporarily dropped, but will be reacquired before
</span></span></span><span class=line><span class=cl><span class=c1>// returning.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Must not have write barriers because this may be called without a P.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//go:nowritebarrierrec
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>startm</span><span class=p>(</span><span class=nx>pp</span> <span class=o>*</span><span class=nx>p</span><span class=p>,</span> <span class=nx>spinning</span><span class=p>,</span> <span class=nx>lockheld</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Disable preemption.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Every owned P must have an owner that will eventually stop it in the
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// event of a GC stop request. startm takes transient ownership of a P
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// (either from argument or pidleget below) and transfers ownership to
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// a started M, which will be responsible for performing the stop.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Preemption must be disabled during this transient ownership,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// otherwise the P this is running on may enter GC stop while still
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// holding the transient P, leaving that P in limbo and deadlocking the
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// STW.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Callers passing a non-nil P must already be in non-preemptible
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// context, otherwise such preemption could occur on function entry to
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// startm. Callers passing a nil P may be preemptible, so we must
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// disable preemption before acquiring a P from pidleget below.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 阻止抢占
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>mp</span> <span class=o>:=</span> <span class=nf>acquirem</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>lockheld</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 通过 wakep 调用的 pp != nil，但是调用 startm 不一定是 wakep，说明 m 的调度还有其他方式
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>pp</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>spinning</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// TODO(prattmic): All remaining calls to this function
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// with _p_ == nil could be cleaned up to find a P
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// before calling startm.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;startm: P required for spinning=true&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 获取空闲 p
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>pp</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nf>pidleget</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 获取不到返回
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>pp</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>!</span><span class=nx>lockheld</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nf>releasem</span><span class=p>(</span><span class=nx>mp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 从 midle 中获取空闲 m
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>nmp</span> <span class=o>:=</span> <span class=nf>mget</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>nmp</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// No M is available, we must drop sched.lock and call newm.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// However, we already own a P to assign to the M.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// Once sched.lock is released, another G (e.g., in a syscall),
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// could find no idle P while checkdead finds a runnable G but
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// no running M&#39;s because this new M hasn&#39;t started yet, thus
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// throwing in an apparent deadlock.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// This apparent deadlock is possible when startm is called
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// from sysmon, which doesn&#39;t count as a running M.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// Avoid this situation by pre-allocating the ID for the new M,
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// thus marking it as &#39;running&#39; before we drop sched.lock. This
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// new M will eventually run the scheduler to execute any
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// queued G&#39;s.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>id</span> <span class=o>:=</span> <span class=nf>mReserveID</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=nx>fn</span> <span class=kd>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>spinning</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// The caller incremented nmspinning, so set m.spinning in the new M.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>fn</span> <span class=p>=</span> <span class=nx>mspinning</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nf>newm</span><span class=p>(</span><span class=nx>fn</span><span class=p>,</span> <span class=nx>pp</span><span class=p>,</span> <span class=nx>id</span><span class=p>)</span> <span class=c1>// 创建新的 m，并绑定 p
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>lockheld</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Ownership transfer of pp committed by start in newm.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// Preemption is now safe.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>releasem</span><span class=p>(</span><span class=nx>mp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>lockheld</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>nmp</span><span class=p>.</span><span class=nx>spinning</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;startm: m is spinning&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>nmp</span><span class=p>.</span><span class=nx>nextp</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;startm: m has p&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>spinning</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nf>runqempty</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;startm: p has runnable gs&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// The caller incremented nmspinning, so set m.spinning in the new M.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>nmp</span><span class=p>.</span><span class=nx>spinning</span> <span class=p>=</span> <span class=nx>spinning</span>
</span></span><span class=line><span class=cl>	<span class=nx>nmp</span><span class=p>.</span><span class=nx>nextp</span><span class=p>.</span><span class=nf>set</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span> <span class=c1>// 把 p 放到了 nextp 的位置
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>notewakeup</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>nmp</span><span class=p>.</span><span class=nx>park</span><span class=p>)</span> <span class=c1>// 使用 futex 系统调用唤醒 m
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Ownership transfer of pp committed by wakeup. Preemption is now
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// safe.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>releasem</span><span class=p>(</span><span class=nx>mp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Try to get an m from midle list.
</span></span></span><span class=line><span class=cl><span class=c1>// sched.lock must be held.
</span></span></span><span class=line><span class=cl><span class=c1>// May run during STW, so write barriers are not allowed.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//go:nowritebarrierrec
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>mget</span><span class=p>()</span> <span class=o>*</span><span class=nx>m</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>assertLockHeld</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>mp</span> <span class=o>:=</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>midle</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>mp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>sched</span><span class=p>.</span><span class=nx>midle</span> <span class=p>=</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>schedlink</span>
</span></span><span class=line><span class=cl>		<span class=nx>sched</span><span class=p>.</span><span class=nx>nmidle</span><span class=o>--</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>mp</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>notewakeup</span><span class=p>(</span><span class=nx>n</span> <span class=o>*</span><span class=nx>note</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>old</span> <span class=o>:=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>Xchg</span><span class=p>(</span><span class=nf>key32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>n</span><span class=p>.</span><span class=nx>key</span><span class=p>),</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>old</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>print</span><span class=p>(</span><span class=s>&#34;notewakeup - double wakeup (&#34;</span><span class=p>,</span> <span class=nx>old</span><span class=p>,</span> <span class=s>&#34;)\n&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;notewakeup - double wakeup&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>futexwakeup</span><span class=p>(</span><span class=nf>key32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>n</span><span class=p>.</span><span class=nx>key</span><span class=p>),</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>通过 <code>wakep</code> 知道 <code>startm</code> 是所有 <code>m</code> 运行的起点，初始时仅有程序启动时的 <code>m0</code>，其他 <code>m</code> 的创建通过 <code>newm</code> 函数，接下来看下新的 <code>m</code> 怎么创建地。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span><span class=lnt>195
</span><span class=lnt>196
</span><span class=lnt>197
</span><span class=lnt>198
</span><span class=lnt>199
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Create a new m. It will start off with a call to fn, or else the scheduler.
</span></span></span><span class=line><span class=cl><span class=c1>// fn needs to be static and not a heap allocated closure.
</span></span></span><span class=line><span class=cl><span class=c1>// May run with m.p==nil, so write barriers are not allowed.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// id is optional pre-allocated m ID. Omit by passing -1.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//go:nowritebarrierrec
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>newm</span><span class=p>(</span><span class=nx>fn</span> <span class=kd>func</span><span class=p>(),</span> <span class=nx>pp</span> <span class=o>*</span><span class=nx>p</span><span class=p>,</span> <span class=nx>id</span> <span class=kt>int64</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// allocm adds a new M to allm, but they do not start until created by
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// the OS in newm1 or the template thread.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// doAllThreadsSyscall requires that every M in allm will eventually
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// start and be signal-able, even with a STW.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Disable preemption here until we start the thread to ensure that
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// newm is not preempted between allocm and starting the new thread,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// ensuring that anything added to allm is guaranteed to eventually
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// start.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>acquirem</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 获取 m 并绑定 startfn，下面有分析
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>mp</span> <span class=o>:=</span> <span class=nf>allocm</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span> <span class=nx>fn</span><span class=p>,</span> <span class=nx>id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>mp</span><span class=p>.</span><span class=nx>nextp</span><span class=p>.</span><span class=nf>set</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span> <span class=c1>// 绑定 p 到 nextp 等待调度拉起
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>mp</span><span class=p>.</span><span class=nx>sigmask</span> <span class=p>=</span> <span class=nx>initSigmask</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 在锁定的 m 或者 cgo 上执行，当前 m 的状态不适合启动新 m，所以这里使用 newmHandoff 上的 templateThread 启动
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>gp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>();</span> <span class=nx>gp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>m</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>lockedExt</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>incgo</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=nx>GOOS</span> <span class=o>!=</span> <span class=s>&#34;plan9&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// We&#39;re on a locked M or a thread that may have been
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// started by C. The kernel state of this thread may
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// be strange (the user may have locked it for that
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// purpose). We don&#39;t want to clone that into another
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// thread. Instead, ask a known-good thread to create
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// the thread for us.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// This is disabled on Plan 9. See golang.org/issue/22227.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// TODO: This may be unnecessary on Windows, which
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// doesn&#39;t model thread creation off fork.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>newmHandoff</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>newmHandoff</span><span class=p>.</span><span class=nx>haveTemplateThread</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;on a locked thread with no template thread&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>mp</span><span class=p>.</span><span class=nx>schedlink</span> <span class=p>=</span> <span class=nx>newmHandoff</span><span class=p>.</span><span class=nx>newm</span>
</span></span><span class=line><span class=cl>		<span class=nx>newmHandoff</span><span class=p>.</span><span class=nx>newm</span><span class=p>.</span><span class=nf>set</span><span class=p>(</span><span class=nx>mp</span><span class=p>)</span> <span class=c1>// 将 m 交给 newmHandoff
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>newmHandoff</span><span class=p>.</span><span class=nx>waiting</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>newmHandoff</span><span class=p>.</span><span class=nx>waiting</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>			<span class=nf>notewakeup</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>newmHandoff</span><span class=p>.</span><span class=nx>wake</span><span class=p>)</span> <span class=c1>// futex 唤醒 newmHandoff
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>newmHandoff</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1>// The M has not started yet, but the template thread does not
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// participate in STW, so it will always process queued Ms and
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// it is safe to releasem.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>releasem</span><span class=p>(</span><span class=nf>getg</span><span class=p>().</span><span class=nx>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 实际为新的 m 创建对应的系统线程，在这之前只是 go 中的 m 结构体
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>newm1</span><span class=p>(</span><span class=nx>mp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>releasem</span><span class=p>(</span><span class=nf>getg</span><span class=p>().</span><span class=nx>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>newm1</span><span class=p>(</span><span class=nx>mp</span> <span class=o>*</span><span class=nx>m</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>iscgo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=nx>ts</span> <span class=nx>cgothreadstart</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>_cgo_thread_start</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;_cgo_thread_start missing&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>ts</span><span class=p>.</span><span class=nx>g</span><span class=p>.</span><span class=nf>set</span><span class=p>(</span><span class=nx>mp</span><span class=p>.</span><span class=nx>g0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>ts</span><span class=p>.</span><span class=nx>tls</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=kt>uint64</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>mp</span><span class=p>.</span><span class=nx>tls</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>		<span class=nx>ts</span><span class=p>.</span><span class=nx>fn</span> <span class=p>=</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>abi</span><span class=p>.</span><span class=nf>FuncPCABI0</span><span class=p>(</span><span class=nx>mstart</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>msanenabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>msanwrite</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>ts</span><span class=p>),</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nx>ts</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>asanenabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>asanwrite</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>ts</span><span class=p>),</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nx>ts</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>execLock</span><span class=p>.</span><span class=nf>rlock</span><span class=p>()</span> <span class=c1>// Prevent process clone.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>asmcgocall</span><span class=p>(</span><span class=nx>_cgo_thread_start</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>ts</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=nx>execLock</span><span class=p>.</span><span class=nf>runlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>execLock</span><span class=p>.</span><span class=nf>rlock</span><span class=p>()</span> <span class=c1>// Prevent process clone.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>newosproc</span><span class=p>(</span><span class=nx>mp</span><span class=p>)</span> <span class=c1>// 系统调用 clone 执行
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>execLock</span><span class=p>.</span><span class=nf>runlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Allocate a new m unassociated with any thread.
</span></span></span><span class=line><span class=cl><span class=c1>// Can use p for allocation context if needed.
</span></span></span><span class=line><span class=cl><span class=c1>// fn is recorded as the new m&#39;s m.mstartfn.
</span></span></span><span class=line><span class=cl><span class=c1>// id is optional pre-allocated m ID. Omit by passing -1.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// This function is allowed to have write barriers even if the caller
</span></span></span><span class=line><span class=cl><span class=c1>// isn&#39;t because it borrows pp.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//go:yeswritebarrierrec
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>allocm</span><span class=p>(</span><span class=nx>pp</span> <span class=o>*</span><span class=nx>p</span><span class=p>,</span> <span class=nx>fn</span> <span class=kd>func</span><span class=p>(),</span> <span class=nx>id</span> <span class=kt>int64</span><span class=p>)</span> <span class=o>*</span><span class=nx>m</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>allocmLock</span><span class=p>.</span><span class=nf>rlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// The caller owns pp, but we may borrow (i.e., acquirep) it. We must
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// disable preemption to ensure it is not stolen, which would make the
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// caller lose ownership.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>acquirem</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>acquirep</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span> <span class=c1>// temporarily borrow p for mallocs in this function
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Release the free M list. We need to do this somewhere and
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// this may free up a stack we can use.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 先清理空闲的 m
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>freem</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=nx>newList</span> <span class=o>*</span><span class=nx>m</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>freem</span> <span class=o>:=</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>freem</span><span class=p>;</span> <span class=nx>freem</span> <span class=o>!=</span> <span class=kc>nil</span><span class=p>;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// wait 是个状态，不是计数，表示当前 freem 是因为什么等待 free
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>wait</span> <span class=o>:=</span> <span class=nx>freem</span><span class=p>.</span><span class=nx>freeWait</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 等待销毁整个 m，那么去掉引用让 gc 销毁
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>if</span> <span class=nx>wait</span> <span class=o>==</span> <span class=nx>freeMWait</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>next</span> <span class=o>:=</span> <span class=nx>freem</span><span class=p>.</span><span class=nx>freelink</span>
</span></span><span class=line><span class=cl>				<span class=nx>freem</span><span class=p>.</span><span class=nx>freelink</span> <span class=p>=</span> <span class=nx>newList</span>
</span></span><span class=line><span class=cl>				<span class=nx>newList</span> <span class=p>=</span> <span class=nx>freem</span>
</span></span><span class=line><span class=cl>				<span class=nx>freem</span> <span class=p>=</span> <span class=nx>next</span>
</span></span><span class=line><span class=cl>				<span class=k>continue</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=c1>// Free the stack if needed. For freeMRef, there is
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// nothing to do except drop freem from the sched.freem
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// list.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 等待清理栈
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>if</span> <span class=nx>wait</span> <span class=o>==</span> <span class=nx>freeMStack</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=c1>// stackfree must be on the system stack, but allocm is
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// reachable off the system stack transitively from
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// startm.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// 系统栈也就是切换到 g0 清理
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=nf>systemstack</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nf>stackfree</span><span class=p>(</span><span class=nx>freem</span><span class=p>.</span><span class=nx>g0</span><span class=p>.</span><span class=nx>stack</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=p>})</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>freem</span> <span class=p>=</span> <span class=nx>freem</span><span class=p>.</span><span class=nx>freelink</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>sched</span><span class=p>.</span><span class=nx>freem</span> <span class=p>=</span> <span class=nx>newList</span>
</span></span><span class=line><span class=cl>		<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>mp</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 绑定 m 开始启动时的函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>mp</span><span class=p>.</span><span class=nx>mstartfn</span> <span class=p>=</span> <span class=nx>fn</span>
</span></span><span class=line><span class=cl>	<span class=nf>mcommoninit</span><span class=p>(</span><span class=nx>mp</span><span class=p>,</span> <span class=nx>id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// In case of cgo or Solaris or illumos or Darwin, pthread_create will make us a stack.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Windows and Plan 9 will layout sched stack on OS stack.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 创建 g0
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>iscgo</span> <span class=o>||</span> <span class=nf>mStackIsSystemAllocated</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>mp</span><span class=p>.</span><span class=nx>g0</span> <span class=p>=</span> <span class=nf>malg</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>mp</span><span class=p>.</span><span class=nx>g0</span> <span class=p>=</span> <span class=nf>malg</span><span class=p>(</span><span class=mi>16384</span> <span class=o>*</span> <span class=nx>sys</span><span class=p>.</span><span class=nx>StackGuardMultiplier</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>mp</span><span class=p>.</span><span class=nx>g0</span><span class=p>.</span><span class=nx>m</span> <span class=p>=</span> <span class=nx>mp</span> <span class=c1>// 双向绑定
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>pp</span> <span class=o>==</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>releasep</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>releasem</span><span class=p>(</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>allocmLock</span><span class=p>.</span><span class=nf>runlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>mp</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>newosproc</span><span class=p>(</span><span class=nx>mp</span> <span class=o>*</span><span class=nx>m</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>stk</span> <span class=o>:=</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>mp</span><span class=p>.</span><span class=nx>g0</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>hi</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>	 * note: strace gets confused if we use CLONE_PTRACE here.
</span></span></span><span class=line><span class=cl><span class=cm>	 */</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=kc>false</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>print</span><span class=p>(</span><span class=s>&#34;newosproc stk=&#34;</span><span class=p>,</span> <span class=nx>stk</span><span class=p>,</span> <span class=s>&#34; m=&#34;</span><span class=p>,</span> <span class=nx>mp</span><span class=p>,</span> <span class=s>&#34; g=&#34;</span><span class=p>,</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>g0</span><span class=p>,</span> <span class=s>&#34; clone=&#34;</span><span class=p>,</span> <span class=nx>abi</span><span class=p>.</span><span class=nf>FuncPCABI0</span><span class=p>(</span><span class=nx>clone</span><span class=p>),</span> <span class=s>&#34; id=&#34;</span><span class=p>,</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>id</span><span class=p>,</span> <span class=s>&#34; ostk=&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>mp</span><span class=p>,</span> <span class=s>&#34;\n&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Disable signals during clone, so that the new thread starts
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// with signals disabled. It will enable them in minit.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kd>var</span> <span class=nx>oset</span> <span class=nx>sigset</span>
</span></span><span class=line><span class=cl>	<span class=nf>sigprocmask</span><span class=p>(</span><span class=nx>_SIG_SETMASK</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>sigset_all</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>oset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>ret</span> <span class=o>:=</span> <span class=nf>retryOnEAGAIN</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>int32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 主要看这里，系统调用 clone，绑定了 mstart 方法，当线程开始执行是，就从这里进入 mstart，mstat 分析见上文 
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>r</span> <span class=o>:=</span> <span class=nf>clone</span><span class=p>(</span><span class=nx>cloneFlags</span><span class=p>,</span> <span class=nx>stk</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>mp</span><span class=p>),</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>mp</span><span class=p>.</span><span class=nx>g0</span><span class=p>),</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>abi</span><span class=p>.</span><span class=nf>FuncPCABI0</span><span class=p>(</span><span class=nx>mstart</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>		<span class=c1>// clone returns positive TID, negative errno.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// We don&#39;t care about the TID.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>r</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=nx>r</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=nf>sigprocmask</span><span class=p>(</span><span class=nx>_SIG_SETMASK</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>oset</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>ret</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>print</span><span class=p>(</span><span class=s>&#34;runtime: failed to create new OS thread (have &#34;</span><span class=p>,</span> <span class=nf>mcount</span><span class=p>(),</span> <span class=s>&#34; already; errno=&#34;</span><span class=p>,</span> <span class=nx>ret</span><span class=p>,</span> <span class=s>&#34;)\n&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>ret</span> <span class=o>==</span> <span class=nx>_EAGAIN</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nb>println</span><span class=p>(</span><span class=s>&#34;runtime: may need to increase max user processes (ulimit -u)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;newosproc&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>wakep</code> 调度使用 <code>startm</code> 获取或创建 <code>m</code> 执行，并设定新的 <code>m</code> 的入口在 <code>mstart</code>，对于新创建的 <code>m</code>，还绑定 <code>spining</code> 作为 <code>mstartfn</code>，获取的空闲的 <code>m</code> 直接等待 <code>futex</code> 唤醒</p><h2 id=m-的调度><code>m</code> 的调度</h2><p>再查找所有调用 <code>startm</code> 的函数，可以找到</p><blockquote><ul><li>一级是直接调用 <code>startm</code> 的函数，二级是直接调用一级的函数</li></ul></blockquote><ul><li><code>handoffp</code>: 让出 <code>p</code> 的情景<ul><li><code>stoplockedm</code>: <code>m</code> 与 <code>g</code> 绑定</li><li><code>mexit</code>: <code>m</code> 结束生命周期</li><li><code>forEachP</code>: <code>gc</code> 使用，将处于 <code>syscall</code> 的 <code>p</code> 强制转为 <code>idle</code></li><li><code>entersyscallblock_handoff</code>: 进入系统调用</li><li><code>retake</code>: <code>sysmon</code> 使长时间占用的 <code>g</code> 让出，<code>running</code> 的 <code>g</code> 设为可被抢占，<code>syscall</code> 的 <code>g</code> 直接 <code>handoffp</code></li></ul></li><li><code>wakep</code>: 唤醒一个 <code>p</code> 的情景<ul><li><code>ready</code></li><li><code>startTheWorldWithSema</code></li><li><code>wakeNetPoller</code></li><li><code>resetspinning</code></li><li><code>schedule</code></li><li><code>newproc</code></li></ul></li><li><code>injectglist</code>: 从定时器或者 <code>gc</code> 获得的任务，需要添加到全局队列中<ul><li><code>findRunnable</code></li><li><code>gcWakeAllAssists</code></li><li><code>*scavengerState.wake</code></li><li><code>startTheWorldWithSema</code></li><li><code>pollWork</code></li><li><code>sysmon</code></li></ul></li><li><code>sysmon</code>: 系统监控</li><li><code>schedEnableUser</code>: <code>gc</code> 内部调度相关<ul><li><code>gcMarkDone</code></li><li><code>gcStart</code></li></ul></li></ul><p>这里就不一一分析函数了(太多了😭)，有兴趣自己看下代码，理解的难度不大。基本可以看出来，调度产生的时刻有</p><ul><li>由于时间片耗尽、线程系统调用阻塞、线程退出等让出 <code>p</code></li><li>系统监控和 <code>gc</code> 产生的任务</li><li>定时器任务</li></ul><p><code>m</code> 的调度都是被动的，是根据 <code>g</code> 和 <code>p</code> 在整个运行时不同状态下，为了使两者平衡即尽可能多的利用所有 <code>p</code> 负载均衡地运行 <code>g</code>。</p><h1 id=还要分析-p-吗>还要分析 <code>p</code> 吗</h1><p>其实到这 <code>p</code> 就没必要分析了，前面已经交杂在一起，<code>gmp</code> 三者不是独立的，通常 <code>g</code> 作为最小调度单元，<code>m</code> 由于绑定线程，作为最终的真实执行单元，<code>p</code> 则起到令牌作用，控制同时最多多少个 <code>m</code> 执行，又因为默认其大小跟 <code>cpu</code> 超线程数一致，所以表现上跟 cpu 一样，有些人又把他称为虚拟 cpu。通常是任务来了，然后找 <code>m</code> 找 <code>p</code> 执行，感觉可以说 <code>g</code> 是任务，<code>mp</code> 是消费者，用户、 <code>gc</code>、定时器都是生产者。</p><h1 id=关于抢占式调度>关于抢占式调度</h1><p>上边的代码在 <code>retake</code> 中可以找到 <code>preemptone</code> 函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Tell the goroutine running on processor P to stop.
</span></span></span><span class=line><span class=cl><span class=c1>// This function is purely best-effort. It can incorrectly fail to inform the
</span></span></span><span class=line><span class=cl><span class=c1>// goroutine. It can inform the wrong goroutine. Even if it informs the
</span></span></span><span class=line><span class=cl><span class=c1>// correct goroutine, that goroutine might ignore the request if it is
</span></span></span><span class=line><span class=cl><span class=c1>// simultaneously executing newstack.
</span></span></span><span class=line><span class=cl><span class=c1>// No lock needs to be held.
</span></span></span><span class=line><span class=cl><span class=c1>// Returns true if preemption request was issued.
</span></span></span><span class=line><span class=cl><span class=c1>// The actual preemption will happen at some point in the future
</span></span></span><span class=line><span class=cl><span class=c1>// and will be indicated by the gp-&gt;status no longer being
</span></span></span><span class=line><span class=cl><span class=c1>// Grunning
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>preemptone</span><span class=p>(</span><span class=nx>pp</span> <span class=o>*</span><span class=nx>p</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>mp</span> <span class=o>:=</span> <span class=nx>pp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>mp</span> <span class=o>==</span> <span class=kc>nil</span> <span class=o>||</span> <span class=nx>mp</span> <span class=o>==</span> <span class=nf>getg</span><span class=p>().</span><span class=nx>m</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span> <span class=o>:=</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>curg</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>gp</span> <span class=o>==</span> <span class=kc>nil</span> <span class=o>||</span> <span class=nx>gp</span> <span class=o>==</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>g0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 设为可抢占
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>gp</span><span class=p>.</span><span class=nx>preempt</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Every call in a goroutine checks for stack overflow by
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// comparing the current stack pointer to gp-&gt;stackguard0.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Setting gp-&gt;stackguard0 to StackPreempt folds
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// preemption into the normal stack overflow check.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// stackguard0 作为栈抢占标记
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>gp</span><span class=p>.</span><span class=nx>stackguard0</span> <span class=p>=</span> <span class=nx>stackPreempt</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Request an async preemption of this P.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>preemptMSupported</span> <span class=o>&amp;&amp;</span> <span class=nx>debug</span><span class=p>.</span><span class=nx>asyncpreemptoff</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>pp</span><span class=p>.</span><span class=nx>preempt</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=nf>preemptM</span><span class=p>(</span><span class=nx>mp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// preemptM sends a preemption request to mp. This request may be
</span></span></span><span class=line><span class=cl><span class=c1>// handled asynchronously and may be coalesced with other requests to
</span></span></span><span class=line><span class=cl><span class=c1>// the M. When the request is received, if the running G or P are
</span></span></span><span class=line><span class=cl><span class=c1>// marked for preemption and the goroutine is at an asynchronous
</span></span></span><span class=line><span class=cl><span class=c1>// safe-point, it will preempt the goroutine. It always atomically
</span></span></span><span class=line><span class=cl><span class=c1>// increments mp.preemptGen after handling a preemption request.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>preemptM</span><span class=p>(</span><span class=nx>mp</span> <span class=o>*</span><span class=nx>m</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// On Darwin, don&#39;t try to preempt threads during exec.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Issue #41702.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>GOOS</span> <span class=o>==</span> <span class=s>&#34;darwin&#34;</span> <span class=o>||</span> <span class=nx>GOOS</span> <span class=o>==</span> <span class=s>&#34;ios&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>execLock</span><span class=p>.</span><span class=nf>rlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>signalPending</span><span class=p>.</span><span class=nf>CompareAndSwap</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>GOOS</span> <span class=o>==</span> <span class=s>&#34;darwin&#34;</span> <span class=o>||</span> <span class=nx>GOOS</span> <span class=o>==</span> <span class=s>&#34;ios&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>pendingPreemptSignals</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// If multiple threads are preempting the same M, it may send many
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// signals to the same M such that it hardly make progress, causing
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// live-lock problem. Apparently this could happen on darwin. See
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// issue #37741.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// Only send a signal if there isn&#39;t already one pending.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 发出抢占信号到线程，信号 sigPreempt = _SIGURG，所以后边寻找信号的处理函数
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>signalM</span><span class=p>(</span><span class=nx>mp</span><span class=p>,</span> <span class=nx>sigPreempt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>GOOS</span> <span class=o>==</span> <span class=s>&#34;darwin&#34;</span> <span class=o>||</span> <span class=nx>GOOS</span> <span class=o>==</span> <span class=s>&#34;ios&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>execLock</span><span class=p>.</span><span class=nf>runlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// sighandler is invoked when a signal occurs. The global g will be
</span></span></span><span class=line><span class=cl><span class=c1>// set to a gsignal goroutine and we will be running on the alternate
</span></span></span><span class=line><span class=cl><span class=c1>// signal stack. The parameter gp will be the value of the global g
</span></span></span><span class=line><span class=cl><span class=c1>// when the signal occurred. The sig, info, and ctxt parameters are
</span></span></span><span class=line><span class=cl><span class=c1>// from the system signal handler: they are the parameters passed when
</span></span></span><span class=line><span class=cl><span class=c1>// the SA is passed to the sigaction system call.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// The garbage collector may have stopped the world, so write barriers
</span></span></span><span class=line><span class=cl><span class=c1>// are not allowed.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//go:nowritebarrierrec
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>sighandler</span><span class=p>(</span><span class=nx>sig</span> <span class=kt>uint32</span><span class=p>,</span> <span class=nx>info</span> <span class=o>*</span><span class=nx>siginfo</span><span class=p>,</span> <span class=nx>ctxt</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>gp</span> <span class=o>*</span><span class=nx>g</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// The g executing the signal handler. This is almost always
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// mp.gsignal. See delayedSignal for an exception.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>gsignal</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>mp</span> <span class=o>:=</span> <span class=nx>gsignal</span><span class=p>.</span><span class=nx>m</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>sigctxt</span><span class=p>{</span><span class=nx>info</span><span class=p>,</span> <span class=nx>ctxt</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>......</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>sig</span> <span class=o>==</span> <span class=nx>sigPreempt</span> <span class=o>&amp;&amp;</span> <span class=nx>debug</span><span class=p>.</span><span class=nx>asyncpreemptoff</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>delayedSignal</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Might be a preemption signal.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>doSigPreempt</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Even if this was definitely a preemption signal, it
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// may have been coalesced with another signal, so we
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// still let it through to the application.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>......</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// doSigPreempt handles a preemption signal on gp.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>doSigPreempt</span><span class=p>(</span><span class=nx>gp</span> <span class=o>*</span><span class=nx>g</span><span class=p>,</span> <span class=nx>ctxt</span> <span class=o>*</span><span class=nx>sigctxt</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Check if this G wants to be preempted and is safe to
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// preempt.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nf>wantAsyncPreempt</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>ok</span><span class=p>,</span> <span class=nx>newpc</span> <span class=o>:=</span> <span class=nf>isAsyncSafePoint</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>ctxt</span><span class=p>.</span><span class=nf>sigpc</span><span class=p>(),</span> <span class=nx>ctxt</span><span class=p>.</span><span class=nf>sigsp</span><span class=p>(),</span> <span class=nx>ctxt</span><span class=p>.</span><span class=nf>siglr</span><span class=p>());</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// Adjust the PC and inject a call to asyncPreempt.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 线程抢占信号执行 asyncPreempt
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>ctxt</span><span class=p>.</span><span class=nf>pushCall</span><span class=p>(</span><span class=nx>abi</span><span class=p>.</span><span class=nf>FuncPCABI0</span><span class=p>(</span><span class=nx>asyncPreempt</span><span class=p>),</span> <span class=nx>newpc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Acknowledge the preemption.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>preemptGen</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>signalPending</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>GOOS</span> <span class=o>==</span> <span class=s>&#34;darwin&#34;</span> <span class=o>||</span> <span class=nx>GOOS</span> <span class=o>==</span> <span class=s>&#34;ios&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>pendingPreemptSignals</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>asyncPreempt</code> 汇编调用 <code>asyncPreempt2</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span><span class=lnt>89
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>//go:generate go run mkpreempt.go
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// asyncPreempt saves all user registers and calls asyncPreempt2.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// When stack scanning encounters an asyncPreempt frame, it scans that
</span></span></span><span class=line><span class=cl><span class=c1>// frame and its parent frame conservatively.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// asyncPreempt is implemented in assembly.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>asyncPreempt</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//go:nosplit
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>asyncPreempt2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>asyncSafePoint</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 判断 g 是否正处于 _GPreempt
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>preemptStop</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>mcall</span><span class=p>(</span><span class=nx>preemptPark</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>mcall</span><span class=p>(</span><span class=nx>gopreempt_m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>asyncSafePoint</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// preemptPark parks gp and puts it in _Gpreempted.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//go:systemstack
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>preemptPark</span><span class=p>(</span><span class=nx>gp</span> <span class=o>*</span><span class=nx>g</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nf>traceEnabled</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>traceGoPark</span><span class=p>(</span><span class=nx>traceBlockPreempted</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>status</span> <span class=o>:=</span> <span class=nf>readgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// g 不在运行，错误抢占
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>status</span><span class=o>&amp;^</span><span class=nx>_Gscan</span> <span class=o>!=</span> <span class=nx>_Grunning</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>dumpgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;bad g status&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>asyncSafePoint</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Double-check that async preemption does not
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// happen in SPWRITE assembly functions.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// isAsyncSafePoint must exclude this case.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>f</span> <span class=o>:=</span> <span class=nf>findfunc</span><span class=p>(</span><span class=nx>gp</span><span class=p>.</span><span class=nx>sched</span><span class=p>.</span><span class=nx>pc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>!</span><span class=nx>f</span><span class=p>.</span><span class=nf>valid</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;preempt at unknown pc&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>f</span><span class=p>.</span><span class=nx>flag</span><span class=o>&amp;</span><span class=nx>abi</span><span class=p>.</span><span class=nx>FuncFlagSPWrite</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nb>println</span><span class=p>(</span><span class=s>&#34;runtime: unexpected SPWRITE function&#34;</span><span class=p>,</span> <span class=nf>funcname</span><span class=p>(</span><span class=nx>f</span><span class=p>),</span> <span class=s>&#34;in async preempt&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;preempt SPWRITE&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Transition from _Grunning to _Gscan|_Gpreempted. We can&#39;t
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// be in _Grunning when we dropg because then we&#39;d be running
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// without an M, but the moment we&#39;re in _Gpreempted,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// something could claim this G before we&#39;ve fully cleaned it
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// up. Hence, we set the scan bit to lock down further
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// transitions until we can dropg.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 状态从 _Grunning 转为 _Gscan|_Gpreempted
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>casGToPreemptScan</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>_Grunning</span><span class=p>,</span> <span class=nx>_Gscan</span><span class=p>|</span><span class=nx>_Gpreempted</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// g 从 m 中解引用
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>dropg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 再次转换
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>casfrom_Gscanstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>_Gscan</span><span class=p>|</span><span class=nx>_Gpreempted</span><span class=p>,</span> <span class=nx>_Gpreempted</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 开始调度
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>schedule</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>gopreempt_m</span><span class=p>(</span><span class=nx>gp</span> <span class=o>*</span><span class=nx>g</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nf>traceEnabled</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>traceGoPreempt</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>goschedImpl</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>goschedImpl</span><span class=p>(</span><span class=nx>gp</span> <span class=o>*</span><span class=nx>g</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>status</span> <span class=o>:=</span> <span class=nf>readgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>status</span><span class=o>&amp;^</span><span class=nx>_Gscan</span> <span class=o>!=</span> <span class=nx>_Grunning</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>dumpgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;bad g status&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>_Grunning</span><span class=p>,</span> <span class=nx>_Grunnable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>dropg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 重新放回全局队列
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>globrunqput</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>schedule</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>调用链最高层是谁调用了 <code>preemptone</code>？</p><ul><li><code>[runtime/mgc.go]</code> -> <code>*gcControllerState.enlistWorker</code></li><li><code>[runtime/proc.go]</code> -> <code>sysmon</code> -> <code>retake</code>: 抢占运行时间过长的 <code>g</code></li><li><code>[runtime/proc.gp]</code> -> <code>gc</code> 相关 -> <code>preemptall</code>: 基本是 <code>STW</code> 场景</li></ul><p>所以总结抢占情景</p><ul><li>程序执行时提前注册 <code>SIGURG</code> 的抢占处理函数</li><li><code>gc STW</code> 或者系统监控发起抢占，都是抢占的安全点</li><li><code>preemptone</code> 调用 <code>preemptM</code> 发出抢占信号</li><li>抢占处理函数完成抢占</li></ul></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>intxff</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2023-11-07</span></p></div><footer class=post-footer><div class=post-tags><a href=/zh-cn/tags/go/>go</a>
<a href=/zh-cn/tags/gmp/>gmp</a></div><nav class=post-nav><a class=next href=/zh-cn/post/go-mutex-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/><span class="next-text nav-default">Go Mutex 源码分析</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=http://localhost:1313 class="iconfont icon-github" title=github></a>
<a href=/zh-cn/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2023<span class=heart><i class="iconfont icon-heart"></i></span><span>intxff</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin=anonymous></script>
<script>var languageCode="zh-cn".replace(/-/g,"_").replace(/_(.*)/,function(e,t){return e.replace(t,t.toUpperCase())});timeago().render(document.querySelectorAll(".timeago"),languageCode),timeago.cancel()</script><script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script>
<script type=text/javascript>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script></body></html>